{"version":3,"sources":["webpack:////Users/sakitam-fdd/Documents/workspace/github/maptalks.deckgl/node_modules/@math.gl/polygon/dist/esm/polygon.js","webpack:////Users/sakitam-fdd/Documents/workspace/github/maptalks.deckgl/node_modules/@math.gl/polygon/dist/esm/utils.js","webpack:////Users/sakitam-fdd/Documents/workspace/github/maptalks.deckgl/node_modules/@math.gl/polygon/dist/esm/lineclip.js","webpack:////Users/sakitam-fdd/Documents/workspace/github/maptalks.deckgl/node_modules/@math.gl/polygon/dist/esm/cut-by-grid.js","webpack:////Users/sakitam-fdd/Documents/workspace/github/maptalks.deckgl/node_modules/@math.gl/polygon/dist/esm/cut-by-mercator-bounds.js","webpack:////Users/sakitam-fdd/Documents/workspace/github/maptalks.deckgl/node_modules/@deck.gl/layers/dist/esm/path-layer/path-tesselator.js","webpack:////Users/sakitam-fdd/Documents/workspace/github/maptalks.deckgl/node_modules/@deck.gl/layers/dist/esm/path-layer/path.js","webpack:////Users/sakitam-fdd/Documents/workspace/github/maptalks.deckgl/node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer.js","webpack:////Users/sakitam-fdd/Documents/workspace/github/maptalks.deckgl/node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer-vertex.glsl.js","webpack:////Users/sakitam-fdd/Documents/workspace/github/maptalks.deckgl/node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer-fragment.glsl.js","webpack:////Users/sakitam-fdd/Documents/workspace/github/maptalks.deckgl/node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.glsl.js","webpack:////Users/sakitam-fdd/Documents/workspace/github/maptalks.deckgl/node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.js","webpack:////Users/sakitam-fdd/Documents/workspace/github/maptalks.deckgl/node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/polygon-tesselator.js","webpack:////Users/sakitam-fdd/Documents/workspace/github/maptalks.deckgl/node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-main.glsl.js","webpack:////Users/sakitam-fdd/Documents/workspace/github/maptalks.deckgl/node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-top.glsl.js","webpack:////Users/sakitam-fdd/Documents/workspace/github/maptalks.deckgl/node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-side.glsl.js","webpack:////Users/sakitam-fdd/Documents/workspace/github/maptalks.deckgl/node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer.js","webpack:////Users/sakitam-fdd/Documents/workspace/github/maptalks.deckgl/node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-fragment.glsl.js","webpack:////Users/sakitam-fdd/Documents/workspace/github/maptalks.deckgl/node_modules/@deck.gl/core/dist/esm/lib/composite-layer.js","webpack:////Users/sakitam-fdd/Documents/workspace/github/maptalks.deckgl/node_modules/@deck.gl/layers/dist/esm/utils.js","webpack:////Users/sakitam-fdd/Documents/workspace/github/maptalks.deckgl/node_modules/@luma.gl/shadertools/dist/esm/modules/phong-lighting/phong-lighting.glsl.js","webpack:////Users/sakitam-fdd/Documents/workspace/github/maptalks.deckgl/node_modules/@luma.gl/shadertools/dist/esm/modules/phong-lighting/phong-lighting.js","webpack:////Users/sakitam-fdd/Documents/workspace/github/maptalks.deckgl/node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/polygon.js","webpack:////Users/sakitam-fdd/Documents/workspace/github/maptalks.deckgl/node_modules/earcut/src/earcut.js","webpack:////Users/sakitam-fdd/Documents/workspace/github/maptalks.deckgl/node_modules/@deck.gl/core/dist/esm/utils/tesselator.js"],"names":["Polygon","points","this","isClosed","length","Object","freeze","key","value","area","forEachSegment","p1","p2","Math","abs","getSignedArea","sign","visitor","i","push","target","source","size","startIndex","isDuplicate","_i","copy","getPointAtIndex","positions","index","offset","out","arguments","undefined","startI","intersect","a","b","edge","bbox","t","snap","bitCode","p","code","cutPolylineByGrid","codeB","options","_options$size","_options$broken","broken","_options$gridResoluti","gridResolution","_options$gridOffset","gridOffset","_options$startIndex","_options$endIndex","endIndex","numPoints","part","result","cell","getGridCell","scratchPoint","codeAlt","moveToNeighborCell","cutPolygonByGrid","holeIndices","_options$size2","_options$gridResoluti2","_options$gridOffset2","_options$edgeTypes","edgeTypes","queue","pos","types","Array","fill","holes","_queue$shift","shift","getBoundingBox","parts","bisectPolygon","polygonLow","polygonHigh","concat","polygon","side","type","resultLow","resultHigh","typesLow","typesHigh","prev","prevSide","prevType","lowPointCount","highPointCount","left","floor","bottom","minX","Infinity","maxX","minY","maxY","x","y","cutPolylineByMercatorBounds","_options$normalize","normalize","newPositions","slice","wrapLongitudesForShortestPath","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","Symbol","iterator","next","done","shiftLongitudesIntoRange","err","cutPolygonByMercatorBounds","_options$normalize2","newHoleIndices","srcStartIndex","targetIndex","ringIndex","srcEndIndex","targetStartIndex","splitIndex","findSplitIndex","insertPoleVertices","maxLatitude","pop","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","maxLat","pointIndex","lat","firstLng","lastLng","round","lng","prevLng","delta","refLng","pointCount","_i2","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","apply","_Tesselator","PathTesselator","opts","call","forEach","getOwnPropertyDescriptors","defineProperties","defineProperty","_objectSpread","attributes","padding","initialize","fp64","Float64Array","Float32Array","segmentTypes","Uint8ClampedArray","buffer","prototype","path","wrapLongitude","flatPath","isArray","j","normalizePath","positionSize","resolution","attributeName","subPath","getGeometrySize","getPathLength","context","geometrySize","updateGeometryAttributes","vertexStart","_updateSegmentTypes","_updatePositions","isPathClosed","ptIndex","getPointOnPath","loop","lastPointIndex","DEFAULT_COLOR","defaultProps","widthUnits","widthScale","min","widthMinPixels","widthMaxPixels","Number","MAX_SAFE_INTEGER","rounded","miterLimit","billboard","_pathType","getPath","getColor","getWidth","ATTRIBUTE_TRANSITION","enter","chunk","subarray","_Layer","PathLayer","vs","fs","modules","project32","picking","_this","getAttributeManager","addInstanced","vertexOffset","use64bitPositions","transition","accessor","update","calculatePositions","noAlloc","shaderAttributes","instanceLeftPositions","instanceStartPositions","instanceEndPositions","instanceRightPositions","instanceTypes","calculateSegmentTypes","instanceStrokeWidths","defaultValue","instanceColors","props","colorFormat","normalized","instancePickingColors","_ref","encodePickingColor","__source","setState","pathTesselator","getDashArray","extensions","log","removed","_ref2","oldProps","changeFlags","attributeManager","dataChanged","updateTriggersChanged","all","state","buffers","data","updateGeometry","geometryBuffer","getGeometry","positionFormat","viewport","numInstances","instanceCount","startIndices","vertexStarts","invalidateAll","extensionsChanged","gl","model","_getModel","params","info","find","d","_ref3","uniforms","_this$props","widthMultiplier","metersPerPixel","setUniforms","assign","jointType","draw","getShaders","id","geometry","drawMode","indices","Uint16Array","isInstanced","attribute","get","layerName","INITIAL_MODULE_OPTIONS","name","getUniforms","lightSources","ambientLight","pointLights","directionalLights","hasLights","getLightSourceUniforms","lighting_uEnabled","lights","light","defines","MAX_LIGHTS","convertColor","_ref$color","color","_ref$intensity","intensity","map","component","_ref2$pointLights","_ref2$directionalLigh","lightSourceUniforms","pointLight","position","attenuation","lighting_uPointLightCount","directionalLight","direction","lighting_uDirectionalLightCount","PolygonTesselator","_opts$IndexType","IndexType","Uint32Array","vertexValid","vertexCount","externalIndices","isFinite","subPolygon","indexStart","indexStarts","geometryIndex","_updateIndices","_updateVertexValid","typedArrayManager","preproject","allocate","polygonPositions","z","set","filled","extruded","wireframe","_normalize","elevationScale","getPolygon","f","getElevation","getFillColor","getLineColor","material","SolidPolygonLayer","_this$context","coordinateSystem","isGeospatial","DEFAULT","LNGLAT","polygonTesselator","projectFlat","ELEMENT_INDEX_UINT32","remove","add","isIndexed","calculateIndices","divisor","instancePositions","nextPositions","calculateVertexValid","elevations","instanceElevations","fillColors","alias","instanceFillColors","lineColors","instanceLineColors","pickingColors","_this$state","topModel","sideModel","renderUniforms","Boolean","setInstanceCount","setDrawMode","isWireframe","setVertexCount","updateParams","models","_getModels","_this$props2","shaders","NON_INSTANCED_MODEL","vertexPositions","isSideVertex","userData","excludeAttributes","CompositeLayer","internalState","subLayers","updateObject","setNeedsUpdate","parent","overridingProps","_subLayerProps","DefaultLayerClass","row","sourceObject","sourceObjectIndex","objectInfo","sublayerProps","opacity","pickable","visible","parameters","getPolygonOffset","highlightedObjectIndex","autoHighlight","highlightColor","coordinateOrigin","modelMatrix","newProps","overridingSublayerProps","overridingSublayerTriggers","updateTriggers","sublayerId","propTypes","constructor","_propTypes","propType","getSubLayerAccessor","extension","passThroughProps","getSubLayerProps","shouldUpdate","needsUpdate","renderLayers","getSubLayers","every","layer","isLoaded","replaceInRange","getIndex","dataRange","replace","_dataRange$startRow","startRow","_dataRange$endRow","endRow","count","replaceStart","replaceEnd","dataLengthChanged","endChunk","gouraudLighting","dependencies","LIGHTING_VERTEX","phongLighting","LIGHTING_FRAGMENT","getMaterialUniforms","_material$ambient","ambient","_material$diffuse","diffuse","_material$shininess","shininess","_material$specularCol","specularColor","lighting_uAmbient","lighting_uDiffuse","lighting_uShininess","lighting_uSpecularColor","isFlatRingClosed","copyNestedRing","simplePolygon","len","p0","isNestedRingClosed","_j","copyFlatRing","srcLength","ArrayBuffer","isView","Error","validate","_polygon","srcPositions","srcHoleIndices","isSimple","_targetIndex","getSurfaceIndices","normalizedPolygon","positionIndex","n","xy","earcut","dim","invSize","hasHoles","outerLen","outerNode","linkedList","triangles","start","end","list","steiner","getLeftmost","sort","compareX","eliminateHole","filterPoints","eliminateHoles","max","earcutLinked","clockwise","last","signedArea","insertNode","equals","removeNode","again","ear","pass","zOrder","prevZ","nextZ","q","e","tail","numMerges","pSize","qSize","inSize","sortLinked","indexCurve","stop","isEarHashed","isEar","cureLocalIntersections","splitEarcut","c","pointInTriangle","minTX","minTY","maxTX","maxTY","minZ","maxZ","intersects","locallyInside","isValidDiagonal","splitPolygon","hole","m","hx","hy","qx","tan","mx","my","tanMin","sectorContainsSector","findHoleBridge","leftmost","ax","ay","bx","by","cx","cy","px","py","intersectsPolygon","inside","middleInside","r","q1","q2","o1","o2","o3","o4","onSegment","num","a2","Node","b2","an","bp","sum","module","exports","default","deviation","polygonArea","trianglesArea","flatten","vertices","dimensions","holeIndex","Tesselator","_opts$attributes","_attributeDefs","seal","_this$opts","_this$opts$buffers","_this$opts$normalize","getGeometryFromBuffer","_rebuildGeometry","stride","release","def","_createIterable","iterable","_ref2$startRow","_ref2$endRow","normalizedData","_forEachGeometry","dataIndex","normalizeGeometry","byteStride","byteLength","bufferValue","elementStride","BYTES_PER_ELEMENT","_allocate","vertexEnd"],"mappings":"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","file":"409a7a661fc974c74a1d2d3eb37fa88a0897aa0d-e40726ce5e15421150bb.js","sourcesContent":["import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport { equals } from '@math.gl/core';\n\nvar Polygon = function () {\n  function Polygon(points) {\n    _classCallCheck(this, Polygon);\n\n    this.points = points;\n    this.isClosed = equals(this.points[this.points.length - 1], this.points[0]);\n    Object.freeze(this);\n  }\n\n  _createClass(Polygon, [{\n    key: \"getSignedArea\",\n    value: function getSignedArea() {\n      var area = 0;\n      this.forEachSegment(function (p1, p2) {\n        area += (p1[0] + p2[0]) * (p1[1] - p2[1]);\n      });\n      return area / 2;\n    }\n  }, {\n    key: \"getArea\",\n    value: function getArea() {\n      return Math.abs(this.getSignedArea());\n    }\n  }, {\n    key: \"getWindingDirection\",\n    value: function getWindingDirection() {\n      return Math.sign(this.getSignedArea());\n    }\n  }, {\n    key: \"forEachSegment\",\n    value: function forEachSegment(visitor) {\n      var length = this.points.length;\n\n      for (var i = 0; i < length - 1; i++) {\n        visitor(this.points[i], this.points[i + 1], i, i + 1);\n      }\n\n      if (!this.isClosed) {\n        visitor(this.points[length - 1], this.points[0], length - 1, 0);\n      }\n    }\n  }]);\n\n  return Polygon;\n}();\n\nexport { Polygon as default };","export function push(target, source) {\n  var size = source.length;\n  var startIndex = target.length;\n\n  if (startIndex > 0) {\n    var isDuplicate = true;\n\n    for (var i = 0; i < size; i++) {\n      if (target[startIndex - size + i] !== source[i]) {\n        isDuplicate = false;\n        break;\n      }\n    }\n\n    if (isDuplicate) {\n      return false;\n    }\n  }\n\n  for (var _i = 0; _i < size; _i++) {\n    target[startIndex + _i] = source[_i];\n  }\n\n  return true;\n}\nexport function copy(target, source) {\n  var size = source.length;\n\n  for (var i = 0; i < size; i++) {\n    target[i] = source[i];\n  }\n}\nexport function getPointAtIndex(positions, index, size, offset) {\n  var out = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n  var startI = offset + index * size;\n\n  for (var i = 0; i < size; i++) {\n    out[i] = positions[startI + i];\n  }\n\n  return out;\n}","import { push, copy, getPointAtIndex } from './utils';\nexport function clipPolyline(positions, bbox) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _options$size = options.size,\n      size = _options$size === void 0 ? 2 : _options$size,\n      _options$startIndex = options.startIndex,\n      startIndex = _options$startIndex === void 0 ? 0 : _options$startIndex,\n      _options$endIndex = options.endIndex,\n      endIndex = _options$endIndex === void 0 ? positions.length : _options$endIndex;\n  var numPoints = (endIndex - startIndex) / size;\n  var result = [];\n  var part = [];\n  var a;\n  var b;\n  var codeA = -1;\n  var codeB;\n  var lastCode;\n\n  for (var i = 1; i < numPoints; i++) {\n    a = getPointAtIndex(positions, i - 1, size, startIndex, a);\n    b = getPointAtIndex(positions, i, size, startIndex, b);\n\n    if (codeA < 0) {\n      codeA = bitCode(a, bbox);\n    }\n\n    codeB = lastCode = bitCode(b, bbox);\n\n    while (true) {\n      if (!(codeA | codeB)) {\n        push(part, a);\n\n        if (codeB !== lastCode) {\n          push(part, b);\n\n          if (i < numPoints - 1) {\n            result.push(part);\n            part = [];\n          }\n        } else if (i === numPoints - 1) {\n          push(part, b);\n        }\n\n        break;\n      } else if (codeA & codeB) {\n        break;\n      } else if (codeA) {\n        intersect(a, b, codeA, bbox, a);\n        codeA = bitCode(a, bbox);\n      } else {\n        intersect(a, b, codeB, bbox, b);\n        codeB = bitCode(b, bbox);\n      }\n    }\n\n    codeA = lastCode;\n  }\n\n  if (part.length) result.push(part);\n  return result;\n}\nexport function clipPolygon(positions, bbox) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _options$size2 = options.size,\n      size = _options$size2 === void 0 ? 2 : _options$size2,\n      _options$endIndex2 = options.endIndex,\n      endIndex = _options$endIndex2 === void 0 ? positions.length : _options$endIndex2;\n  var _options$startIndex2 = options.startIndex,\n      startIndex = _options$startIndex2 === void 0 ? 0 : _options$startIndex2;\n  var numPoints = (endIndex - startIndex) / size;\n  var result;\n  var p;\n  var prev;\n  var inside;\n  var prevInside;\n\n  for (var edge = 1; edge <= 8; edge *= 2) {\n    result = [];\n    prev = getPointAtIndex(positions, numPoints - 1, size, startIndex, prev);\n    prevInside = !(bitCode(prev, bbox) & edge);\n\n    for (var i = 0; i < numPoints; i++) {\n      p = getPointAtIndex(positions, i, size, startIndex, p);\n      inside = !(bitCode(p, bbox) & edge);\n      if (inside !== prevInside) push(result, intersect(prev, p, edge, bbox));\n      if (inside) push(result, p);\n      copy(prev, p);\n      prevInside = inside;\n    }\n\n    positions = result;\n    startIndex = 0;\n    numPoints = result.length / size;\n    if (!numPoints) break;\n  }\n\n  return result;\n}\nexport function intersect(a, b, edge, bbox) {\n  var out = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n  var t;\n  var snap;\n\n  if (edge & 8) {\n    t = (bbox[3] - a[1]) / (b[1] - a[1]);\n    snap = 3;\n  } else if (edge & 4) {\n    t = (bbox[1] - a[1]) / (b[1] - a[1]);\n    snap = 1;\n  } else if (edge & 2) {\n    t = (bbox[2] - a[0]) / (b[0] - a[0]);\n    snap = 2;\n  } else if (edge & 1) {\n    t = (bbox[0] - a[0]) / (b[0] - a[0]);\n    snap = 0;\n  } else {\n    return null;\n  }\n\n  for (var i = 0; i < a.length; i++) {\n    out[i] = (snap & 1) === i ? bbox[snap] : t * b[i] + (1 - t) * a[i];\n  }\n\n  return out;\n}\nexport function bitCode(p, bbox) {\n  var code = 0;\n  if (p[0] < bbox[0]) code |= 1;else if (p[0] > bbox[2]) code |= 2;\n  if (p[1] < bbox[1]) code |= 4;else if (p[1] > bbox[3]) code |= 8;\n  return code;\n}","import { bitCode, intersect } from './lineclip';\nimport { getPointAtIndex, copy, push } from './utils';\nexport function cutPolylineByGrid(positions) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _options$size = options.size,\n      size = _options$size === void 0 ? 2 : _options$size,\n      _options$broken = options.broken,\n      broken = _options$broken === void 0 ? false : _options$broken,\n      _options$gridResoluti = options.gridResolution,\n      gridResolution = _options$gridResoluti === void 0 ? 10 : _options$gridResoluti,\n      _options$gridOffset = options.gridOffset,\n      gridOffset = _options$gridOffset === void 0 ? [0, 0] : _options$gridOffset,\n      _options$startIndex = options.startIndex,\n      startIndex = _options$startIndex === void 0 ? 0 : _options$startIndex,\n      _options$endIndex = options.endIndex,\n      endIndex = _options$endIndex === void 0 ? positions.length : _options$endIndex;\n  var numPoints = (endIndex - startIndex) / size;\n  var part = [];\n  var result = [part];\n  var a = getPointAtIndex(positions, 0, size, startIndex);\n  var b;\n  var codeB;\n  var cell = getGridCell(a, gridResolution, gridOffset, []);\n  var scratchPoint = [];\n  push(part, a);\n\n  for (var i = 1; i < numPoints; i++) {\n    b = getPointAtIndex(positions, i, size, startIndex, b);\n    codeB = bitCode(b, cell);\n\n    while (codeB) {\n      intersect(a, b, codeB, cell, scratchPoint);\n      var codeAlt = bitCode(scratchPoint, cell);\n\n      if (codeAlt) {\n        intersect(a, scratchPoint, codeAlt, cell, scratchPoint);\n        codeB = codeAlt;\n      }\n\n      push(part, scratchPoint);\n      copy(a, scratchPoint);\n      moveToNeighborCell(cell, gridResolution, codeB);\n\n      if (broken && part.length > size) {\n        part = [];\n        result.push(part);\n        push(part, a);\n      }\n\n      codeB = bitCode(b, cell);\n    }\n\n    push(part, b);\n    copy(a, b);\n  }\n\n  return broken ? result : result[0];\n}\nvar TYPE_INSIDE = 0;\nvar TYPE_BORDER = 1;\nexport function cutPolygonByGrid(positions, holeIndices) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (!positions.length) {\n    return [];\n  }\n\n  var _options$size2 = options.size,\n      size = _options$size2 === void 0 ? 2 : _options$size2,\n      _options$gridResoluti2 = options.gridResolution,\n      gridResolution = _options$gridResoluti2 === void 0 ? 10 : _options$gridResoluti2,\n      _options$gridOffset2 = options.gridOffset,\n      gridOffset = _options$gridOffset2 === void 0 ? [0, 0] : _options$gridOffset2,\n      _options$edgeTypes = options.edgeTypes,\n      edgeTypes = _options$edgeTypes === void 0 ? false : _options$edgeTypes;\n  var result = [];\n  var queue = [{\n    pos: positions,\n    types: edgeTypes && new Array(positions.length / size).fill(TYPE_BORDER),\n    holes: holeIndices || []\n  }];\n  var bbox = [[], []];\n  var cell = [];\n\n  while (queue.length) {\n    var _queue$shift = queue.shift(),\n        pos = _queue$shift.pos,\n        types = _queue$shift.types,\n        holes = _queue$shift.holes;\n\n    getBoundingBox(pos, size, bbox);\n    cell = getGridCell(bbox[0], gridResolution, gridOffset, cell);\n    var code = bitCode(bbox[1], cell);\n\n    if (code) {\n      var parts = bisectPolygon(pos, types, size, 0, holes[0] || pos.length, cell, code);\n      var polygonLow = {\n        pos: parts[0].pos,\n        types: parts[0].types,\n        holes: []\n      };\n      var polygonHigh = {\n        pos: parts[1].pos,\n        types: parts[1].types,\n        holes: []\n      };\n      queue.push(polygonLow, polygonHigh);\n\n      for (var i = 0; i < holes.length; i++) {\n        parts = bisectPolygon(pos, types, size, holes[i], holes[i + 1] || pos.length, cell, code);\n\n        if (parts[0]) {\n          polygonLow.holes.push(polygonLow.pos.length);\n          polygonLow.pos = polygonLow.pos.concat(parts[0].pos);\n\n          if (edgeTypes) {\n            polygonLow.types = polygonLow.types.concat(parts[0].types);\n          }\n        }\n\n        if (parts[1]) {\n          polygonHigh.holes.push(polygonHigh.pos.length);\n          polygonHigh.pos = polygonHigh.pos.concat(parts[1].pos);\n\n          if (edgeTypes) {\n            polygonHigh.types = polygonHigh.types.concat(parts[1].types);\n          }\n        }\n      }\n    } else {\n      var polygon = {\n        positions: pos\n      };\n\n      if (edgeTypes) {\n        polygon.edgeTypes = types;\n      }\n\n      if (holes.length) {\n        polygon.holeIndices = holes;\n      }\n\n      result.push(polygon);\n    }\n  }\n\n  return result;\n}\n\nfunction bisectPolygon(positions, edgeTypes, size, startIndex, endIndex, bbox, edge) {\n  var numPoints = (endIndex - startIndex) / size;\n  var resultLow = [];\n  var resultHigh = [];\n  var typesLow = [];\n  var typesHigh = [];\n  var scratchPoint = [];\n  var p;\n  var side;\n  var type;\n  var prev = getPointAtIndex(positions, numPoints - 1, size, startIndex);\n  var prevSide = Math.sign(edge & 8 ? prev[1] - bbox[3] : prev[0] - bbox[2]);\n  var prevType = edgeTypes && edgeTypes[numPoints - 1];\n  var lowPointCount = 0;\n  var highPointCount = 0;\n\n  for (var i = 0; i < numPoints; i++) {\n    p = getPointAtIndex(positions, i, size, startIndex, p);\n    side = Math.sign(edge & 8 ? p[1] - bbox[3] : p[0] - bbox[2]);\n    type = edgeTypes && edgeTypes[startIndex / size + i];\n\n    if (side && prevSide && prevSide !== side) {\n      intersect(prev, p, edge, bbox, scratchPoint);\n      push(resultLow, scratchPoint) && typesLow.push(prevType);\n      push(resultHigh, scratchPoint) && typesHigh.push(prevType);\n    }\n\n    if (side <= 0) {\n      push(resultLow, p) && typesLow.push(type);\n      lowPointCount -= side;\n    } else if (typesLow.length) {\n      typesLow[typesLow.length - 1] = TYPE_INSIDE;\n    }\n\n    if (side >= 0) {\n      push(resultHigh, p) && typesHigh.push(type);\n      highPointCount += side;\n    } else if (typesHigh.length) {\n      typesHigh[typesHigh.length - 1] = TYPE_INSIDE;\n    }\n\n    copy(prev, p);\n    prevSide = side;\n    prevType = type;\n  }\n\n  return [lowPointCount ? {\n    pos: resultLow,\n    types: edgeTypes && typesLow\n  } : null, highPointCount ? {\n    pos: resultHigh,\n    types: edgeTypes && typesHigh\n  } : null];\n}\n\nfunction getGridCell(p, gridResolution, gridOffset, out) {\n  var left = Math.floor((p[0] - gridOffset[0]) / gridResolution) * gridResolution + gridOffset[0];\n  var bottom = Math.floor((p[1] - gridOffset[1]) / gridResolution) * gridResolution + gridOffset[1];\n  out[0] = left;\n  out[1] = bottom;\n  out[2] = left + gridResolution;\n  out[3] = bottom + gridResolution;\n  return out;\n}\n\nfunction moveToNeighborCell(cell, gridResolution, edge) {\n  if (edge & 8) {\n    cell[1] += gridResolution;\n    cell[3] += gridResolution;\n  } else if (edge & 4) {\n    cell[1] -= gridResolution;\n    cell[3] -= gridResolution;\n  } else if (edge & 2) {\n    cell[0] += gridResolution;\n    cell[2] += gridResolution;\n  } else if (edge & 1) {\n    cell[0] -= gridResolution;\n    cell[2] -= gridResolution;\n  }\n}\n\nfunction getBoundingBox(positions, size, out) {\n  var minX = Infinity;\n  var maxX = -Infinity;\n  var minY = Infinity;\n  var maxY = -Infinity;\n\n  for (var i = 0; i < positions.length; i += size) {\n    var x = positions[i];\n    var y = positions[i + 1];\n    minX = x < minX ? x : minX;\n    maxX = x > maxX ? x : maxX;\n    minY = y < minY ? y : minY;\n    maxY = y > maxY ? y : maxY;\n  }\n\n  out[0][0] = minX;\n  out[0][1] = minY;\n  out[1][0] = maxX;\n  out[1][1] = maxY;\n  return out;\n}","import { cutPolylineByGrid, cutPolygonByGrid } from './cut-by-grid';\nimport { getPointAtIndex, push } from './utils';\nvar DEFAULT_MAX_LATITUDE = 85.051129;\nexport function cutPolylineByMercatorBounds(positions) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _options$size = options.size,\n      size = _options$size === void 0 ? 2 : _options$size,\n      _options$startIndex = options.startIndex,\n      startIndex = _options$startIndex === void 0 ? 0 : _options$startIndex,\n      _options$endIndex = options.endIndex,\n      endIndex = _options$endIndex === void 0 ? positions.length : _options$endIndex,\n      _options$normalize = options.normalize,\n      normalize = _options$normalize === void 0 ? true : _options$normalize;\n  var newPositions = positions.slice(startIndex, endIndex);\n  wrapLongitudesForShortestPath(newPositions, size, 0, endIndex - startIndex);\n  var parts = cutPolylineByGrid(newPositions, {\n    size: size,\n    broken: true,\n    gridResolution: 360,\n    gridOffset: [-180, -180]\n  });\n\n  if (normalize) {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = parts[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var part = _step.value;\n        shiftLongitudesIntoRange(part, size);\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n          _iterator[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  }\n\n  return parts;\n}\nexport function cutPolygonByMercatorBounds(positions, holeIndices) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _options$size2 = options.size,\n      size = _options$size2 === void 0 ? 2 : _options$size2,\n      _options$normalize2 = options.normalize,\n      normalize = _options$normalize2 === void 0 ? true : _options$normalize2,\n      _options$edgeTypes = options.edgeTypes,\n      edgeTypes = _options$edgeTypes === void 0 ? false : _options$edgeTypes;\n  holeIndices = holeIndices || [];\n  var newPositions = [];\n  var newHoleIndices = [];\n  var srcStartIndex = 0;\n  var targetIndex = 0;\n\n  for (var ringIndex = 0; ringIndex <= holeIndices.length; ringIndex++) {\n    var srcEndIndex = holeIndices[ringIndex] || positions.length;\n    var targetStartIndex = targetIndex;\n    var splitIndex = findSplitIndex(positions, size, srcStartIndex, srcEndIndex);\n\n    for (var i = splitIndex; i < srcEndIndex; i++) {\n      newPositions[targetIndex++] = positions[i];\n    }\n\n    for (var _i = srcStartIndex; _i < splitIndex; _i++) {\n      newPositions[targetIndex++] = positions[_i];\n    }\n\n    wrapLongitudesForShortestPath(newPositions, size, targetStartIndex, targetIndex);\n    insertPoleVertices(newPositions, size, targetStartIndex, targetIndex, options.maxLatitude);\n    srcStartIndex = srcEndIndex;\n    newHoleIndices[ringIndex] = targetIndex;\n  }\n\n  newHoleIndices.pop();\n  var parts = cutPolygonByGrid(newPositions, newHoleIndices, {\n    size: size,\n    gridResolution: 360,\n    gridOffset: [-180, -180],\n    edgeTypes: edgeTypes\n  });\n\n  if (normalize) {\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = parts[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var part = _step2.value;\n        shiftLongitudesIntoRange(part.positions, size);\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n          _iterator2[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n  }\n\n  return parts;\n}\n\nfunction findSplitIndex(positions, size, startIndex, endIndex) {\n  var maxLat = -1;\n  var pointIndex = -1;\n\n  for (var i = startIndex + 1; i < endIndex; i += size) {\n    var lat = Math.abs(positions[i]);\n\n    if (lat > maxLat) {\n      maxLat = lat;\n      pointIndex = i - 1;\n    }\n  }\n\n  return pointIndex;\n}\n\nfunction insertPoleVertices(positions, size, startIndex, endIndex) {\n  var maxLatitude = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : DEFAULT_MAX_LATITUDE;\n  var firstLng = positions[startIndex];\n  var lastLng = positions[endIndex - size];\n\n  if (Math.abs(firstLng - lastLng) > 180) {\n    var p = getPointAtIndex(positions, 0, size, startIndex);\n    p[0] += Math.round((lastLng - firstLng) / 360) * 360;\n    push(positions, p);\n    p[1] = Math.sign(p[1]) * maxLatitude;\n    push(positions, p);\n    p[0] = firstLng;\n    push(positions, p);\n  }\n}\n\nfunction wrapLongitudesForShortestPath(positions, size, startIndex, endIndex) {\n  var prevLng = positions[0];\n  var lng;\n\n  for (var i = startIndex; i < endIndex; i += size) {\n    lng = positions[i];\n    var delta = lng - prevLng;\n\n    if (delta > 180 || delta < -180) {\n      lng -= Math.round(delta / 360) * 360;\n    }\n\n    positions[i] = prevLng = lng;\n  }\n}\n\nfunction shiftLongitudesIntoRange(positions, size) {\n  var refLng;\n  var pointCount = positions.length / size;\n\n  for (var i = 0; i < pointCount; i++) {\n    refLng = positions[i * size];\n\n    if ((refLng + 180) % 360 !== 0) {\n      break;\n    }\n  }\n\n  var delta = -Math.round(refLng / 360) * 360;\n\n  if (delta === 0) {\n    return;\n  }\n\n  for (var _i2 = 0; _i2 < pointCount; _i2++) {\n    positions[_i2 * size] += delta;\n  }\n}","import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"@babel/runtime/helpers/esm/get\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport { Tesselator } from '@deck.gl/core';\nimport { normalizePath } from './path';\nvar START_CAP = 1;\nvar END_CAP = 2;\nvar INVALID = 4;\n\nvar PathTesselator = function (_Tesselator) {\n  _inherits(PathTesselator, _Tesselator);\n\n  function PathTesselator(opts) {\n    _classCallCheck(this, PathTesselator);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(PathTesselator).call(this, _objectSpread({}, opts, {\n      attributes: {\n        positions: {\n          size: 3,\n          padding: 18,\n          initialize: true,\n          type: opts.fp64 ? Float64Array : Float32Array\n        },\n        segmentTypes: {\n          size: 1,\n          type: Uint8ClampedArray\n        }\n      }\n    })));\n  }\n\n  _createClass(PathTesselator, [{\n    key: \"getGeometryFromBuffer\",\n    value: function getGeometryFromBuffer(buffer) {\n      if (this.normalize) {\n        return _get(_getPrototypeOf(PathTesselator.prototype), \"getGeometryFromBuffer\", this).call(this, buffer);\n      }\n\n      return function () {\n        return null;\n      };\n    }\n  }, {\n    key: \"normalizeGeometry\",\n    value: function normalizeGeometry(path) {\n      if (this.normalize) {\n        return normalizePath(path, this.positionSize, this.opts.resolution, this.opts.wrapLongitude);\n      }\n\n      return path;\n    }\n  }, {\n    key: \"get\",\n    value: function get(attributeName) {\n      return this.attributes[attributeName];\n    }\n  }, {\n    key: \"getGeometrySize\",\n    value: function getGeometrySize(path) {\n      if (Array.isArray(path[0])) {\n        var size = 0;\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = path[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var subPath = _step.value;\n            size += this.getGeometrySize(subPath);\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n              _iterator[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n\n        return size;\n      }\n\n      var numPoints = this.getPathLength(path);\n\n      if (numPoints < 2) {\n        return 0;\n      }\n\n      if (this.isClosed(path)) {\n        return numPoints < 3 ? 0 : numPoints + 2;\n      }\n\n      return numPoints;\n    }\n  }, {\n    key: \"updateGeometryAttributes\",\n    value: function updateGeometryAttributes(path, context) {\n      if (context.geometrySize === 0) {\n        return;\n      }\n\n      if (path && Array.isArray(path[0])) {\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = path[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var subPath = _step2.value;\n            var geometrySize = this.getGeometrySize(subPath);\n            context.geometrySize = geometrySize;\n            this.updateGeometryAttributes(subPath, context);\n            context.vertexStart += geometrySize;\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n              _iterator2[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n      } else {\n        this._updateSegmentTypes(path, context);\n\n        this._updatePositions(path, context);\n      }\n    }\n  }, {\n    key: \"_updateSegmentTypes\",\n    value: function _updateSegmentTypes(path, context) {\n      var segmentTypes = this.attributes.segmentTypes;\n      var isPathClosed = this.isClosed(path);\n      var vertexStart = context.vertexStart,\n          geometrySize = context.geometrySize;\n      segmentTypes.fill(0, vertexStart, vertexStart + geometrySize);\n\n      if (isPathClosed) {\n        segmentTypes[vertexStart] = INVALID;\n        segmentTypes[vertexStart + geometrySize - 2] = INVALID;\n      } else {\n        segmentTypes[vertexStart] += START_CAP;\n        segmentTypes[vertexStart + geometrySize - 2] += END_CAP;\n      }\n\n      segmentTypes[vertexStart + geometrySize - 1] = INVALID;\n    }\n  }, {\n    key: \"_updatePositions\",\n    value: function _updatePositions(path, context) {\n      var positions = this.attributes.positions;\n\n      if (!positions) {\n        return;\n      }\n\n      var vertexStart = context.vertexStart,\n          geometrySize = context.geometrySize;\n      var p = new Array(3);\n\n      for (var i = vertexStart, ptIndex = 0; ptIndex < geometrySize; i++, ptIndex++) {\n        this.getPointOnPath(path, ptIndex, p);\n        positions[i * 3] = p[0];\n        positions[i * 3 + 1] = p[1];\n        positions[i * 3 + 2] = p[2];\n      }\n    }\n  }, {\n    key: \"getPathLength\",\n    value: function getPathLength(path) {\n      return path.length / this.positionSize;\n    }\n  }, {\n    key: \"getPointOnPath\",\n    value: function getPointOnPath(path, index) {\n      var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n      var positionSize = this.positionSize;\n\n      if (index * positionSize >= path.length) {\n        index += 1 - path.length / positionSize;\n      }\n\n      var i = index * positionSize;\n      target[0] = path[i];\n      target[1] = path[i + 1];\n      target[2] = positionSize === 3 && path[i + 2] || 0;\n      return target;\n    }\n  }, {\n    key: \"isClosed\",\n    value: function isClosed(path) {\n      if (!this.normalize) {\n        return this.opts.loop;\n      }\n\n      var positionSize = this.positionSize;\n      var lastPointIndex = path.length - positionSize;\n      return path[0] === path[lastPointIndex] && path[1] === path[lastPointIndex + 1] && (positionSize === 2 || path[2] === path[lastPointIndex + 2]);\n    }\n  }]);\n\n  return PathTesselator;\n}(Tesselator);\n\nexport { PathTesselator as default };","import { cutPolylineByGrid, cutPolylineByMercatorBounds } from '@math.gl/polygon';\nexport function normalizePath(path, size, gridResolution, wrapLongitude) {\n  var flatPath = path;\n\n  if (Array.isArray(path[0])) {\n    var length = path.length * size;\n    flatPath = new Array(length);\n\n    for (var i = 0; i < path.length; i++) {\n      for (var j = 0; j < size; j++) {\n        flatPath[i * size + j] = path[i][j] || 0;\n      }\n    }\n  }\n\n  if (gridResolution) {\n    return cutPolylineByGrid(flatPath, {\n      size: size,\n      gridResolution: gridResolution\n    });\n  }\n\n  if (wrapLongitude) {\n    return cutPolylineByMercatorBounds(flatPath, {\n      size: size\n    });\n  }\n\n  return flatPath;\n}","import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"@babel/runtime/helpers/esm/get\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport { Layer, project32, picking, log } from '@deck.gl/core';\nimport { Model, Geometry } from '@luma.gl/core';\nimport PathTesselator from './path-tesselator';\nimport vs from './path-layer-vertex.glsl';\nimport fs from './path-layer-fragment.glsl';\nvar DEFAULT_COLOR = [0, 0, 0, 255];\nvar defaultProps = {\n  widthUnits: 'meters',\n  widthScale: {\n    type: 'number',\n    min: 0,\n    value: 1\n  },\n  widthMinPixels: {\n    type: 'number',\n    min: 0,\n    value: 0\n  },\n  widthMaxPixels: {\n    type: 'number',\n    min: 0,\n    value: Number.MAX_SAFE_INTEGER\n  },\n  rounded: false,\n  miterLimit: {\n    type: 'number',\n    min: 0,\n    value: 4\n  },\n  billboard: false,\n  _pathType: null,\n  getPath: {\n    type: 'accessor',\n    value: function value(object) {\n      return object.path;\n    }\n  },\n  getColor: {\n    type: 'accessor',\n    value: DEFAULT_COLOR\n  },\n  getWidth: {\n    type: 'accessor',\n    value: 1\n  }\n};\nvar ATTRIBUTE_TRANSITION = {\n  enter: function enter(value, chunk) {\n    return chunk.length ? chunk.subarray(chunk.length - value.length) : value;\n  }\n};\n\nvar PathLayer = function (_Layer) {\n  _inherits(PathLayer, _Layer);\n\n  function PathLayer() {\n    _classCallCheck(this, PathLayer);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(PathLayer).apply(this, arguments));\n  }\n\n  _createClass(PathLayer, [{\n    key: \"getShaders\",\n    value: function getShaders() {\n      return _get(_getPrototypeOf(PathLayer.prototype), \"getShaders\", this).call(this, {\n        vs: vs,\n        fs: fs,\n        modules: [project32, picking]\n      });\n    }\n  }, {\n    key: \"initializeState\",\n    value: function initializeState() {\n      var _this = this;\n\n      var noAlloc = true;\n      var attributeManager = this.getAttributeManager();\n      attributeManager.addInstanced({\n        positions: {\n          size: 3,\n          vertexOffset: 1,\n          type: 5130,\n          fp64: this.use64bitPositions(),\n          transition: ATTRIBUTE_TRANSITION,\n          accessor: 'getPath',\n          update: this.calculatePositions,\n          noAlloc: noAlloc,\n          shaderAttributes: {\n            instanceLeftPositions: {\n              vertexOffset: 0\n            },\n            instanceStartPositions: {\n              vertexOffset: 1\n            },\n            instanceEndPositions: {\n              vertexOffset: 2\n            },\n            instanceRightPositions: {\n              vertexOffset: 3\n            }\n          }\n        },\n        instanceTypes: {\n          size: 1,\n          type: 5121,\n          update: this.calculateSegmentTypes,\n          noAlloc: noAlloc\n        },\n        instanceStrokeWidths: {\n          size: 1,\n          accessor: 'getWidth',\n          transition: ATTRIBUTE_TRANSITION,\n          defaultValue: 1\n        },\n        instanceColors: {\n          size: this.props.colorFormat.length,\n          type: 5121,\n          normalized: true,\n          accessor: 'getColor',\n          transition: ATTRIBUTE_TRANSITION,\n          defaultValue: DEFAULT_COLOR\n        },\n        instancePickingColors: {\n          size: 3,\n          type: 5121,\n          accessor: function accessor(object, _ref) {\n            var index = _ref.index,\n                value = _ref.target;\n            return _this.encodePickingColor(object && object.__source ? object.__source.index : index, value);\n          }\n        }\n      });\n      this.setState({\n        pathTesselator: new PathTesselator({\n          fp64: this.use64bitPositions()\n        })\n      });\n\n      if (this.props.getDashArray && !this.props.extensions.length) {\n        log.removed('getDashArray', 'PathStyleExtension')();\n      }\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(_ref2) {\n      var oldProps = _ref2.oldProps,\n          props = _ref2.props,\n          changeFlags = _ref2.changeFlags;\n\n      _get(_getPrototypeOf(PathLayer.prototype), \"updateState\", this).call(this, {\n        props: props,\n        oldProps: oldProps,\n        changeFlags: changeFlags\n      });\n\n      var attributeManager = this.getAttributeManager();\n      var geometryChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPath);\n\n      if (geometryChanged) {\n        var pathTesselator = this.state.pathTesselator;\n        var buffers = props.data.attributes || {};\n        pathTesselator.updateGeometry({\n          data: props.data,\n          geometryBuffer: buffers.getPath,\n          buffers: buffers,\n          normalize: !props._pathType,\n          loop: props._pathType === 'loop',\n          getGeometry: props.getPath,\n          positionFormat: props.positionFormat,\n          wrapLongitude: props.wrapLongitude,\n          resolution: this.context.viewport.resolution,\n          dataChanged: changeFlags.dataChanged\n        });\n        this.setState({\n          numInstances: pathTesselator.instanceCount,\n          startIndices: pathTesselator.vertexStarts\n        });\n\n        if (!changeFlags.dataChanged) {\n          attributeManager.invalidateAll();\n        }\n      }\n\n      if (changeFlags.extensionsChanged) {\n        var gl = this.context.gl;\n\n        if (this.state.model) {\n          this.state.model[\"delete\"]();\n        }\n\n        this.setState({\n          model: this._getModel(gl)\n        });\n        attributeManager.invalidateAll();\n      }\n    }\n  }, {\n    key: \"getPickingInfo\",\n    value: function getPickingInfo(params) {\n      var info = _get(_getPrototypeOf(PathLayer.prototype), \"getPickingInfo\", this).call(this, params);\n\n      var index = info.index;\n      var data = this.props.data;\n\n      if (data[0] && data[0].__source) {\n        info.object = data.find(function (d) {\n          return d.__source.index === index;\n        });\n      }\n\n      return info;\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(_ref3) {\n      var uniforms = _ref3.uniforms;\n      var viewport = this.context.viewport;\n      var _this$props = this.props,\n          rounded = _this$props.rounded,\n          billboard = _this$props.billboard,\n          miterLimit = _this$props.miterLimit,\n          widthUnits = _this$props.widthUnits,\n          widthScale = _this$props.widthScale,\n          widthMinPixels = _this$props.widthMinPixels,\n          widthMaxPixels = _this$props.widthMaxPixels;\n      var widthMultiplier = widthUnits === 'pixels' ? viewport.metersPerPixel : 1;\n      this.state.model.setUniforms(Object.assign({}, uniforms, {\n        jointType: Number(rounded),\n        billboard: billboard,\n        widthScale: widthScale * widthMultiplier,\n        miterLimit: miterLimit,\n        widthMinPixels: widthMinPixels,\n        widthMaxPixels: widthMaxPixels\n      })).draw();\n    }\n  }, {\n    key: \"_getModel\",\n    value: function _getModel(gl) {\n      var SEGMENT_INDICES = [0, 1, 2, 1, 4, 2, 1, 3, 4, 3, 5, 4];\n      var SEGMENT_POSITIONS = [0, 0, 0, -1, 0, 1, 1, -1, 1, 1, 1, 0];\n      return new Model(gl, Object.assign({}, this.getShaders(), {\n        id: this.props.id,\n        geometry: new Geometry({\n          drawMode: 4,\n          attributes: {\n            indices: new Uint16Array(SEGMENT_INDICES),\n            positions: {\n              value: new Float32Array(SEGMENT_POSITIONS),\n              size: 2\n            }\n          }\n        }),\n        isInstanced: true\n      }));\n    }\n  }, {\n    key: \"calculatePositions\",\n    value: function calculatePositions(attribute) {\n      var pathTesselator = this.state.pathTesselator;\n      attribute.startIndices = pathTesselator.vertexStarts;\n      attribute.value = pathTesselator.get('positions');\n    }\n  }, {\n    key: \"calculateSegmentTypes\",\n    value: function calculateSegmentTypes(attribute) {\n      var pathTesselator = this.state.pathTesselator;\n      attribute.startIndices = pathTesselator.vertexStarts;\n      attribute.value = pathTesselator.get('segmentTypes');\n    }\n  }, {\n    key: \"wrapLongitude\",\n    get: function get() {\n      return false;\n    }\n  }]);\n\n  return PathLayer;\n}(Layer);\n\nexport { PathLayer as default };\nPathLayer.layerName = 'PathLayer';\nPathLayer.defaultProps = defaultProps;","export default \"#define SHADER_NAME path-layer-vertex-shader\\n\\nattribute vec2 positions;\\n\\nattribute float instanceTypes;\\nattribute vec3 instanceStartPositions;\\nattribute vec3 instanceEndPositions;\\nattribute vec3 instanceLeftPositions;\\nattribute vec3 instanceRightPositions;\\nattribute vec3 instanceLeftPositions64Low;\\nattribute vec3 instanceStartPositions64Low;\\nattribute vec3 instanceEndPositions64Low;\\nattribute vec3 instanceRightPositions64Low;\\nattribute float instanceStrokeWidths;\\nattribute vec4 instanceColors;\\nattribute vec3 instancePickingColors;\\n\\nuniform float widthScale;\\nuniform float widthMinPixels;\\nuniform float widthMaxPixels;\\nuniform float jointType;\\nuniform float miterLimit;\\nuniform bool billboard;\\n\\nuniform float opacity;\\n\\nvarying vec4 vColor;\\nvarying vec2 vCornerOffset;\\nvarying float vMiterLength;\\nvarying vec2 vPathPosition;\\nvarying float vPathLength;\\n\\nconst float EPSILON = 0.001;\\nconst vec3 ZERO_OFFSET = vec3(0.0);\\n\\nfloat flipIfTrue(bool flag) {\\n  return -(float(flag) * 2. - 1.);\\n}\\nvec3 lineJoin(\\n  vec3 prevPoint, vec3 currPoint, vec3 nextPoint,\\n  vec2 width\\n) {\\n  bool isEnd = positions.x > 0.0;\\n  float sideOfPath = positions.y;\\n  float isJoint = float(sideOfPath == 0.0);\\n\\n  vec3 deltaA3 = (currPoint - prevPoint);\\n  vec3 deltaB3 = (nextPoint - currPoint);\\n\\n  mat3 rotationMatrix;\\n  bool needsRotation = !billboard && project_needs_rotation(currPoint, rotationMatrix);\\n  if (needsRotation) {\\n    deltaA3 = deltaA3 * rotationMatrix;\\n    deltaB3 = deltaB3 * rotationMatrix;\\n  }\\n  vec2 deltaA = deltaA3.xy / width;\\n  vec2 deltaB = deltaB3.xy / width;\\n\\n  float lenA = length(deltaA);\\n  float lenB = length(deltaB);\\n\\n  vec2 dirA = lenA > 0. ? normalize(deltaA) : vec2(0.0, 0.0);\\n  vec2 dirB = lenB > 0. ? normalize(deltaB) : vec2(0.0, 0.0);\\n\\n  vec2 perpA = vec2(-dirA.y, dirA.x);\\n  vec2 perpB = vec2(-dirB.y, dirB.x);\\n  vec2 tangent = dirA + dirB;\\n  tangent = length(tangent) > 0. ? normalize(tangent) : perpA;\\n  vec2 miterVec = vec2(-tangent.y, tangent.x);\\n  vec2 dir = isEnd ? dirA : dirB;\\n  vec2 perp = isEnd ? perpA : perpB;\\n  float L = isEnd ? lenA : lenB;\\n  float sinHalfA = abs(dot(miterVec, perp));\\n  float cosHalfA = abs(dot(dirA, miterVec));\\n  float turnDirection = flipIfTrue(dirA.x * dirB.y >= dirA.y * dirB.x);\\n  float cornerPosition = sideOfPath * turnDirection;\\n\\n  float miterSize = 1.0 / max(sinHalfA, EPSILON);\\n  miterSize = mix(\\n    min(miterSize, max(lenA, lenB) / max(cosHalfA, EPSILON)),\\n    miterSize,\\n    step(0.0, cornerPosition)\\n  );\\n\\n  vec2 offsetVec = mix(miterVec * miterSize, perp, step(0.5, cornerPosition))\\n    * (sideOfPath + isJoint * turnDirection);\\n  bool isStartCap = lenA == 0.0 || (!isEnd && (instanceTypes == 1.0 || instanceTypes == 3.0));\\n  bool isEndCap = lenB == 0.0 || (isEnd && (instanceTypes == 2.0 || instanceTypes == 3.0));\\n  bool isCap = isStartCap || isEndCap;\\n  if (isCap) {\\n    offsetVec = mix(perp * sideOfPath, dir * jointType * 4.0 * flipIfTrue(isStartCap), isJoint);\\n  }\\n  vPathLength = L;\\n  vCornerOffset = offsetVec;\\n  vMiterLength = dot(vCornerOffset, miterVec * turnDirection);\\n  vMiterLength = isCap ? isJoint : vMiterLength;\\n\\n  vec2 offsetFromStartOfPath = vCornerOffset + deltaA * float(isEnd);\\n  vPathPosition = vec2(\\n    dot(offsetFromStartOfPath, perp),\\n    dot(offsetFromStartOfPath, dir)\\n  );\\n  geometry.uv = vPathPosition;\\n\\n  float isValid = step(instanceTypes, 3.5);\\n  vec3 offset = vec3(offsetVec * width * isValid, 0.0);\\n  DECKGL_FILTER_SIZE(offset, geometry);\\n\\n  if (needsRotation) {\\n    offset = rotationMatrix * offset;\\n  }\\n  return currPoint + offset;\\n}\\nvoid clipLine(inout vec4 position, vec4 refPosition) {\\n  if (position.w < EPSILON) {\\n    float r = (EPSILON - refPosition.w) / (position.w - refPosition.w);\\n    position = refPosition + (position - refPosition) * r;\\n  }\\n}\\n\\nvoid main() {\\n  geometry.worldPosition = instanceStartPositions;\\n  geometry.worldPositionAlt = instanceEndPositions;\\n  geometry.pickingColor = instancePickingColors;\\n\\n  vec2 widthPixels = vec2(clamp(project_size_to_pixel(instanceStrokeWidths * widthScale),\\n    widthMinPixels, widthMaxPixels) / 2.0);\\n\\n  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity);\\n\\n  float isEnd = positions.x;\\n\\n  vec3 prevPosition = mix(instanceLeftPositions, instanceStartPositions, isEnd);\\n  vec3 prevPosition64Low = mix(instanceLeftPositions64Low, instanceStartPositions64Low, isEnd);\\n\\n  vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);\\n  vec3 currPosition64Low = mix(instanceStartPositions64Low, instanceEndPositions64Low, isEnd);\\n\\n  vec3 nextPosition = mix(instanceEndPositions, instanceRightPositions, isEnd);\\n  vec3 nextPosition64Low = mix(instanceEndPositions64Low, instanceRightPositions64Low, isEnd);\\n\\n  if (billboard) {\\n    vec4 prevPositionScreen = project_position_to_clipspace(prevPosition, prevPosition64Low, ZERO_OFFSET);\\n    vec4 currPositionScreen = project_position_to_clipspace(currPosition, currPosition64Low, ZERO_OFFSET, geometry.position);\\n    vec4 nextPositionScreen = project_position_to_clipspace(nextPosition, nextPosition64Low, ZERO_OFFSET);\\n\\n    clipLine(prevPositionScreen, currPositionScreen);\\n    clipLine(nextPositionScreen, currPositionScreen);\\n    clipLine(currPositionScreen, mix(nextPositionScreen, prevPositionScreen, isEnd));\\n\\n    vec2 width = project_pixel_size_to_clipspace(widthPixels);\\n\\n    vec3 pos = lineJoin(\\n      prevPositionScreen.xyz / prevPositionScreen.w,\\n      currPositionScreen.xyz / currPositionScreen.w,\\n      nextPositionScreen.xyz / nextPositionScreen.w,\\n      width\\n    );\\n\\n    gl_Position = vec4(pos * currPositionScreen.w, currPositionScreen.w);\\n  } else {\\n    prevPosition = project_position(prevPosition, prevPosition64Low);\\n    currPosition = project_position(currPosition, currPosition64Low);\\n    nextPosition = project_position(nextPosition, nextPosition64Low);\\n\\n    vec2 width = project_pixel_size(widthPixels);\\n\\n    vec4 pos = vec4(\\n      lineJoin(prevPosition, currPosition, nextPosition, width),\\n      1.0);\\n    geometry.position = pos;\\n    gl_Position = project_common_position_to_clipspace(pos);\\n  }\\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\\n  DECKGL_FILTER_COLOR(vColor, geometry);\\n}\\n\";","export default \"#define SHADER_NAME path-layer-fragment-shader\\n\\nprecision highp float;\\n\\nuniform float jointType;\\nuniform float miterLimit;\\n\\nvarying vec4 vColor;\\nvarying vec2 vCornerOffset;\\nvarying float vMiterLength;\\nvarying vec2 vPathPosition;\\nvarying float vPathLength;\\n\\nvoid main(void) {\\n  geometry.uv = vPathPosition;\\n\\n  if (vPathPosition.y < 0.0 || vPathPosition.y > vPathLength) {\\n    if (jointType > 0.0 && length(vCornerOffset) > 1.0) {\\n      discard;\\n    }\\n    if (jointType == 0.0 && vMiterLength > miterLimit + 1.0) {\\n      discard;\\n    }\\n  }\\n  gl_FragColor = vColor;\\n\\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\\n}\\n\";","export default \"#if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))\\n\\nstruct AmbientLight {\\n vec3 color;\\n};\\n\\nstruct PointLight {\\n vec3 color;\\n vec3 position;\\n vec3 attenuation;\\n};\\n\\nstruct DirectionalLight {\\n  vec3 color;\\n  vec3 direction;\\n};\\n\\nuniform AmbientLight lighting_uAmbientLight;\\nuniform PointLight lighting_uPointLight[MAX_LIGHTS];\\nuniform DirectionalLight lighting_uDirectionalLight[MAX_LIGHTS];\\nuniform int lighting_uPointLightCount;\\nuniform int lighting_uDirectionalLightCount;\\n\\nuniform bool lighting_uEnabled;\\n\\nfloat getPointLightAttenuation(PointLight pointLight, float distance) {\\n  return pointLight.attenuation.x\\n       + pointLight.attenuation.y * distance\\n       + pointLight.attenuation.z * distance * distance;\\n}\\n\\n#endif\\n\";","import lightingShader from './lights.glsl';\nexport default {\n  name: 'lights',\n  vs: lightingShader,\n  fs: lightingShader,\n  getUniforms: getUniforms,\n  defines: {\n    MAX_LIGHTS: 3\n  }\n};\nvar INITIAL_MODULE_OPTIONS = {};\n\nfunction convertColor() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      _ref$color = _ref.color,\n      color = _ref$color === void 0 ? [0, 0, 0] : _ref$color,\n      _ref$intensity = _ref.intensity,\n      intensity = _ref$intensity === void 0 ? 1.0 : _ref$intensity;\n\n  return color.map(function (component) {\n    return component * intensity / 255.0;\n  });\n}\n\nfunction getLightSourceUniforms(_ref2) {\n  var ambientLight = _ref2.ambientLight,\n      _ref2$pointLights = _ref2.pointLights,\n      pointLights = _ref2$pointLights === void 0 ? [] : _ref2$pointLights,\n      _ref2$directionalLigh = _ref2.directionalLights,\n      directionalLights = _ref2$directionalLigh === void 0 ? [] : _ref2$directionalLigh;\n  var lightSourceUniforms = {};\n\n  if (ambientLight) {\n    lightSourceUniforms['lighting_uAmbientLight.color'] = convertColor(ambientLight);\n  } else {\n    lightSourceUniforms['lighting_uAmbientLight.color'] = [0, 0, 0];\n  }\n\n  pointLights.forEach(function (pointLight, index) {\n    lightSourceUniforms[\"lighting_uPointLight[\".concat(index, \"].color\")] = convertColor(pointLight);\n    lightSourceUniforms[\"lighting_uPointLight[\".concat(index, \"].position\")] = pointLight.position;\n    lightSourceUniforms[\"lighting_uPointLight[\".concat(index, \"].attenuation\")] = pointLight.attenuation || [1, 0, 0];\n  });\n  lightSourceUniforms.lighting_uPointLightCount = pointLights.length;\n  directionalLights.forEach(function (directionalLight, index) {\n    lightSourceUniforms[\"lighting_uDirectionalLight[\".concat(index, \"].color\")] = convertColor(directionalLight);\n    lightSourceUniforms[\"lighting_uDirectionalLight[\".concat(index, \"].direction\")] = directionalLight.direction;\n  });\n  lightSourceUniforms.lighting_uDirectionalLightCount = directionalLights.length;\n  return lightSourceUniforms;\n}\n\nfunction getUniforms() {\n  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : INITIAL_MODULE_OPTIONS;\n\n  if ('lightSources' in opts) {\n    var _ref3 = opts.lightSources || {},\n        ambientLight = _ref3.ambientLight,\n        pointLights = _ref3.pointLights,\n        directionalLights = _ref3.directionalLights;\n\n    var hasLights = ambientLight || pointLights && pointLights.length > 0 || directionalLights && directionalLights.length > 0;\n\n    if (!hasLights) {\n      return {\n        lighting_uEnabled: false\n      };\n    }\n\n    return Object.assign({}, getLightSourceUniforms({\n      ambientLight: ambientLight,\n      pointLights: pointLights,\n      directionalLights: directionalLights\n    }), {\n      lighting_uEnabled: true\n    });\n  }\n\n  if ('lights' in opts) {\n    var lightSources = {\n      pointLights: [],\n      directionalLights: []\n    };\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = (opts.lights || [])[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var light = _step.value;\n\n        switch (light.type) {\n          case 'ambient':\n            lightSources.ambientLight = light;\n            break;\n\n          case 'directional':\n            lightSources.directionalLights.push(light);\n            break;\n\n          case 'point':\n            lightSources.pointLights.push(light);\n            break;\n\n          default:\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n          _iterator[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return getUniforms({\n      lightSources: lightSources\n    });\n  }\n\n  return {};\n}","import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"@babel/runtime/helpers/esm/get\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport * as Polygon from './polygon';\nimport { Tesselator } from '@deck.gl/core';\nimport { cutPolygonByGrid, cutPolygonByMercatorBounds } from '@math.gl/polygon';\n\nvar PolygonTesselator = function (_Tesselator) {\n  _inherits(PolygonTesselator, _Tesselator);\n\n  function PolygonTesselator(opts) {\n    _classCallCheck(this, PolygonTesselator);\n\n    var fp64 = opts.fp64,\n        _opts$IndexType = opts.IndexType,\n        IndexType = _opts$IndexType === void 0 ? Uint32Array : _opts$IndexType;\n    return _possibleConstructorReturn(this, _getPrototypeOf(PolygonTesselator).call(this, _objectSpread({}, opts, {\n      attributes: {\n        positions: {\n          size: 3,\n          type: fp64 ? Float64Array : Float32Array\n        },\n        vertexValid: {\n          type: Uint8ClampedArray,\n          size: 1\n        },\n        indices: {\n          type: IndexType,\n          size: 1\n        }\n      }\n    })));\n  }\n\n  _createClass(PolygonTesselator, [{\n    key: \"get\",\n    value: function get(attributeName) {\n      var attributes = this.attributes;\n\n      if (attributeName === 'indices') {\n        return attributes.indices && attributes.indices.subarray(0, this.vertexCount);\n      }\n\n      return attributes[attributeName];\n    }\n  }, {\n    key: \"updateGeometry\",\n    value: function updateGeometry(opts) {\n      _get(_getPrototypeOf(PolygonTesselator.prototype), \"updateGeometry\", this).call(this, opts);\n\n      var externalIndices = this.buffers.indices;\n\n      if (externalIndices) {\n        this.vertexCount = (externalIndices.value || externalIndices).length;\n      }\n    }\n  }, {\n    key: \"normalizeGeometry\",\n    value: function normalizeGeometry(polygon) {\n      if (this.normalize) {\n        polygon = Polygon.normalize(polygon, this.positionSize);\n\n        if (this.opts.resolution) {\n          return cutPolygonByGrid(polygon.positions || polygon, polygon.holeIndices, {\n            size: this.positionSize,\n            gridResolution: this.opts.resolution,\n            edgeTypes: true\n          });\n        }\n\n        if (this.opts.wrapLongitude) {\n          return cutPolygonByMercatorBounds(polygon.positions || polygon, polygon.holeIndices, {\n            size: this.positionSize,\n            maxLatitude: 86,\n            edgeTypes: true\n          });\n        }\n      }\n\n      return polygon;\n    }\n  }, {\n    key: \"getGeometrySize\",\n    value: function getGeometrySize(polygon) {\n      if (Array.isArray(polygon) && !Number.isFinite(polygon[0])) {\n        var size = 0;\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = polygon[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var subPolygon = _step.value;\n            size += this.getGeometrySize(subPolygon);\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n              _iterator[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n\n        return size;\n      }\n\n      return (polygon.positions || polygon).length / this.positionSize;\n    }\n  }, {\n    key: \"getGeometryFromBuffer\",\n    value: function getGeometryFromBuffer(buffer) {\n      if (this.normalize || !this.buffers.indices) {\n        return _get(_getPrototypeOf(PolygonTesselator.prototype), \"getGeometryFromBuffer\", this).call(this, buffer);\n      }\n\n      return function () {\n        return null;\n      };\n    }\n  }, {\n    key: \"updateGeometryAttributes\",\n    value: function updateGeometryAttributes(polygon, context) {\n      if (Array.isArray(polygon) && !Number.isFinite(polygon[0])) {\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = polygon[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var subPolygon = _step2.value;\n            var geometrySize = this.getGeometrySize(subPolygon);\n            context.geometrySize = geometrySize;\n            this.updateGeometryAttributes(subPolygon, context);\n            context.vertexStart += geometrySize;\n            context.indexStart = this.indexStarts[context.geometryIndex + 1];\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n              _iterator2[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n      } else {\n        this._updateIndices(polygon, context);\n\n        this._updatePositions(polygon, context);\n\n        this._updateVertexValid(polygon, context);\n      }\n    }\n  }, {\n    key: \"_updateIndices\",\n    value: function _updateIndices(polygon, _ref) {\n      var geometryIndex = _ref.geometryIndex,\n          offset = _ref.vertexStart,\n          indexStart = _ref.indexStart;\n      var attributes = this.attributes,\n          indexStarts = this.indexStarts,\n          typedArrayManager = this.typedArrayManager;\n      var target = attributes.indices;\n\n      if (!target) {\n        return;\n      }\n\n      var i = indexStart;\n      var indices = Polygon.getSurfaceIndices(polygon, this.positionSize, this.opts.preproject);\n      target = typedArrayManager.allocate(target, indexStart + indices.length, {\n        copy: true\n      });\n\n      for (var j = 0; j < indices.length; j++) {\n        target[i++] = indices[j] + offset;\n      }\n\n      indexStarts[geometryIndex + 1] = indexStart + indices.length;\n      attributes.indices = target;\n    }\n  }, {\n    key: \"_updatePositions\",\n    value: function _updatePositions(polygon, _ref2) {\n      var vertexStart = _ref2.vertexStart,\n          geometrySize = _ref2.geometrySize;\n      var positions = this.attributes.positions,\n          positionSize = this.positionSize;\n\n      if (!positions) {\n        return;\n      }\n\n      var polygonPositions = polygon.positions || polygon;\n\n      for (var i = vertexStart, j = 0; j < geometrySize; i++, j++) {\n        var x = polygonPositions[j * positionSize];\n        var y = polygonPositions[j * positionSize + 1];\n        var z = positionSize > 2 ? polygonPositions[j * positionSize + 2] : 0;\n        positions[i * 3] = x;\n        positions[i * 3 + 1] = y;\n        positions[i * 3 + 2] = z;\n      }\n    }\n  }, {\n    key: \"_updateVertexValid\",\n    value: function _updateVertexValid(polygon, _ref3) {\n      var vertexStart = _ref3.vertexStart,\n          geometrySize = _ref3.geometrySize;\n      var vertexValid = this.attributes.vertexValid,\n          positionSize = this.positionSize;\n      var holeIndices = polygon && polygon.holeIndices;\n\n      if (polygon && polygon.edgeTypes) {\n        vertexValid.set(polygon.edgeTypes, vertexStart);\n      } else {\n        vertexValid.fill(1, vertexStart, vertexStart + geometrySize);\n      }\n\n      if (holeIndices) {\n        for (var j = 0; j < holeIndices.length; j++) {\n          vertexValid[vertexStart + holeIndices[j] / positionSize - 1] = 0;\n        }\n      }\n\n      vertexValid[vertexStart + geometrySize - 1] = 0;\n    }\n  }]);\n\n  return PolygonTesselator;\n}(Tesselator);\n\nexport { PolygonTesselator as default };","export default \"\\nattribute vec2 vertexPositions;\\nattribute float vertexValid;\\n\\nuniform bool extruded;\\nuniform bool isWireframe;\\nuniform float elevationScale;\\nuniform float opacity;\\n\\nvarying vec4 vColor;\\nvarying float isValid;\\n\\nstruct PolygonProps {\\n  vec4 fillColors;\\n  vec4 lineColors;\\n  vec3 positions;\\n  vec3 nextPositions;\\n  vec3 pickingColors;\\n  vec3 positions64Low;\\n  vec3 nextPositions64Low;\\n  float elevations;\\n};\\n\\nvec3 project_offset_normal(vec3 vector) {\\n  if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\\n    project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSETS) {\\n    return normalize(vector * project_uCommonUnitsPerWorldUnit);\\n  }\\n  return project_normal(vector);\\n}\\n\\nvoid calculatePosition(PolygonProps props) {\\n  vec3 pos;\\n  vec3 pos64Low;\\n  vec3 normal;\\n  vec4 colors = isWireframe ? props.lineColors : props.fillColors;\\n\\n  geometry.worldPosition = props.positions;\\n  geometry.worldPositionAlt = props.nextPositions;\\n  geometry.pickingColor = props.pickingColors;\\n\\n#ifdef IS_SIDE_VERTEX\\n  pos = mix(props.positions, props.nextPositions, vertexPositions.x);\\n  pos64Low = mix(props.positions64Low, props.nextPositions64Low, vertexPositions.x);\\n  isValid = vertexValid;\\n#else\\n  pos = props.positions;\\n  pos64Low = props.positions64Low;\\n  isValid = 1.0;\\n#endif\\n\\n  if (extruded) {\\n    pos.z += props.elevations * vertexPositions.y * elevationScale;\\n    \\n#ifdef IS_SIDE_VERTEX\\n    normal = vec3(props.positions.y - props.nextPositions.y, props.nextPositions.x - props.positions.x, 0.0);\\n    normal = project_offset_normal(normal);\\n#else\\n    normal = vec3(0.0, 0.0, 1.0);\\n#endif\\n    geometry.normal = normal;\\n  }\\n\\n  gl_Position = project_position_to_clipspace(pos, pos64Low, vec3(0.), geometry.position);\\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\\n\\n  if (extruded) {\\n    vec3 lightColor = lighting_getLightColor(colors.rgb, project_uCameraPosition, geometry.position.xyz, normal);\\n    vColor = vec4(lightColor, colors.a * opacity);\\n  } else {\\n    vColor = vec4(colors.rgb, colors.a * opacity);\\n  }\\n  DECKGL_FILTER_COLOR(vColor, geometry);\\n}\\n\";","import main from './solid-polygon-layer-vertex-main.glsl';\nexport default \"#define SHADER_NAME solid-polygon-layer-vertex-shader\\n\\nattribute vec3 positions;\\nattribute vec3 positions64Low;\\nattribute float elevations;\\nattribute vec4 fillColors;\\nattribute vec4 lineColors;\\nattribute vec3 pickingColors;\\n\\n\".concat(main, \"\\n\\nvoid main(void) {\\n  PolygonProps props;\\n\\n  props.positions = positions;\\n  props.positions64Low = positions64Low;\\n  props.elevations = elevations;\\n  props.fillColors = fillColors;\\n  props.lineColors = lineColors;\\n  props.pickingColors = pickingColors;\\n\\n  calculatePosition(props);\\n}\\n\");","import main from './solid-polygon-layer-vertex-main.glsl';\nexport default \"#define SHADER_NAME solid-polygon-layer-vertex-shader-side\\n#define IS_SIDE_VERTEX\\n\\n\\nattribute vec3 instancePositions;\\nattribute vec3 nextPositions;\\nattribute vec3 instancePositions64Low;\\nattribute vec3 nextPositions64Low;\\nattribute float instanceElevations;\\nattribute vec4 instanceFillColors;\\nattribute vec4 instanceLineColors;\\nattribute vec3 instancePickingColors;\\n\\n\".concat(main, \"\\n\\nvoid main(void) {\\n  PolygonProps props;\\n\\n  props.positions = instancePositions;\\n  props.positions64Low = instancePositions64Low;\\n  props.elevations = instanceElevations;\\n  props.fillColors = instanceFillColors;\\n  props.lineColors = instanceLineColors;\\n  props.pickingColors = instancePickingColors;\\n  props.nextPositions = nextPositions;\\n  props.nextPositions64Low = nextPositions64Low;\\n\\n  calculatePosition(props);\\n}\\n\");","import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"@babel/runtime/helpers/esm/get\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport { Layer, project32, gouraudLighting, picking, COORDINATE_SYSTEM } from '@deck.gl/core';\nimport { Model, Geometry, hasFeatures, FEATURES } from '@luma.gl/core';\nimport PolygonTesselator from './polygon-tesselator';\nimport vsTop from './solid-polygon-layer-vertex-top.glsl';\nimport vsSide from './solid-polygon-layer-vertex-side.glsl';\nimport fs from './solid-polygon-layer-fragment.glsl';\nvar DEFAULT_COLOR = [0, 0, 0, 255];\nvar defaultProps = {\n  filled: true,\n  extruded: false,\n  wireframe: false,\n  _normalize: true,\n  elevationScale: {\n    type: 'number',\n    min: 0,\n    value: 1\n  },\n  getPolygon: {\n    type: 'accessor',\n    value: function value(f) {\n      return f.polygon;\n    }\n  },\n  getElevation: {\n    type: 'accessor',\n    value: 1000\n  },\n  getFillColor: {\n    type: 'accessor',\n    value: DEFAULT_COLOR\n  },\n  getLineColor: {\n    type: 'accessor',\n    value: DEFAULT_COLOR\n  },\n  material: true\n};\nvar ATTRIBUTE_TRANSITION = {\n  enter: function enter(value, chunk) {\n    return chunk.length ? chunk.subarray(chunk.length - value.length) : value;\n  }\n};\n\nvar SolidPolygonLayer = function (_Layer) {\n  _inherits(SolidPolygonLayer, _Layer);\n\n  function SolidPolygonLayer() {\n    _classCallCheck(this, SolidPolygonLayer);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(SolidPolygonLayer).apply(this, arguments));\n  }\n\n  _createClass(SolidPolygonLayer, [{\n    key: \"getShaders\",\n    value: function getShaders(vs) {\n      return _get(_getPrototypeOf(SolidPolygonLayer.prototype), \"getShaders\", this).call(this, {\n        vs: vs,\n        fs: fs,\n        defines: {},\n        modules: [project32, gouraudLighting, picking]\n      });\n    }\n  }, {\n    key: \"initializeState\",\n    value: function initializeState() {\n      var _this = this;\n\n      var _this$context = this.context,\n          gl = _this$context.gl,\n          viewport = _this$context.viewport;\n      var coordinateSystem = this.props.coordinateSystem;\n\n      if (viewport.isGeospatial && coordinateSystem === COORDINATE_SYSTEM.DEFAULT) {\n        coordinateSystem = COORDINATE_SYSTEM.LNGLAT;\n      }\n\n      this.setState({\n        numInstances: 0,\n        polygonTesselator: new PolygonTesselator({\n          preproject: coordinateSystem === COORDINATE_SYSTEM.LNGLAT && viewport.projectFlat,\n          fp64: this.use64bitPositions(),\n          IndexType: !gl || hasFeatures(gl, FEATURES.ELEMENT_INDEX_UINT32) ? Uint32Array : Uint16Array\n        })\n      });\n      var attributeManager = this.getAttributeManager();\n      var noAlloc = true;\n      attributeManager.remove(['instancePickingColors']);\n      attributeManager.add({\n        indices: {\n          size: 1,\n          isIndexed: true,\n          update: this.calculateIndices,\n          noAlloc: noAlloc\n        },\n        positions: {\n          size: 3,\n          type: 5130,\n          fp64: this.use64bitPositions(),\n          transition: ATTRIBUTE_TRANSITION,\n          accessor: 'getPolygon',\n          update: this.calculatePositions,\n          noAlloc: noAlloc,\n          shaderAttributes: {\n            positions: {\n              vertexOffset: 0,\n              divisor: 0\n            },\n            instancePositions: {\n              vertexOffset: 0,\n              divisor: 1\n            },\n            nextPositions: {\n              vertexOffset: 1,\n              divisor: 1\n            }\n          }\n        },\n        vertexValid: {\n          size: 1,\n          divisor: 1,\n          type: 5121,\n          update: this.calculateVertexValid,\n          noAlloc: noAlloc\n        },\n        elevations: {\n          size: 1,\n          transition: ATTRIBUTE_TRANSITION,\n          accessor: 'getElevation',\n          shaderAttributes: {\n            elevations: {\n              divisor: 0\n            },\n            instanceElevations: {\n              divisor: 1\n            }\n          }\n        },\n        fillColors: {\n          alias: 'colors',\n          size: this.props.colorFormat.length,\n          type: 5121,\n          normalized: true,\n          transition: ATTRIBUTE_TRANSITION,\n          accessor: 'getFillColor',\n          defaultValue: DEFAULT_COLOR,\n          shaderAttributes: {\n            fillColors: {\n              divisor: 0\n            },\n            instanceFillColors: {\n              divisor: 1\n            }\n          }\n        },\n        lineColors: {\n          alias: 'colors',\n          size: this.props.colorFormat.length,\n          type: 5121,\n          normalized: true,\n          transition: ATTRIBUTE_TRANSITION,\n          accessor: 'getLineColor',\n          defaultValue: DEFAULT_COLOR,\n          shaderAttributes: {\n            lineColors: {\n              divisor: 0\n            },\n            instanceLineColors: {\n              divisor: 1\n            }\n          }\n        },\n        pickingColors: {\n          size: 3,\n          type: 5121,\n          accessor: function accessor(object, _ref) {\n            var index = _ref.index,\n                value = _ref.target;\n            return _this.encodePickingColor(object && object.__source ? object.__source.index : index, value);\n          },\n          shaderAttributes: {\n            pickingColors: {\n              divisor: 0\n            },\n            instancePickingColors: {\n              divisor: 1\n            }\n          }\n        }\n      });\n    }\n  }, {\n    key: \"getPickingInfo\",\n    value: function getPickingInfo(params) {\n      var info = _get(_getPrototypeOf(SolidPolygonLayer.prototype), \"getPickingInfo\", this).call(this, params);\n\n      var index = info.index;\n      var data = this.props.data;\n\n      if (data[0] && data[0].__source) {\n        info.object = data.find(function (d) {\n          return d.__source.index === index;\n        });\n      }\n\n      return info;\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(_ref2) {\n      var uniforms = _ref2.uniforms;\n      var _this$props = this.props,\n          extruded = _this$props.extruded,\n          filled = _this$props.filled,\n          wireframe = _this$props.wireframe,\n          elevationScale = _this$props.elevationScale;\n      var _this$state = this.state,\n          topModel = _this$state.topModel,\n          sideModel = _this$state.sideModel,\n          polygonTesselator = _this$state.polygonTesselator;\n      var renderUniforms = Object.assign({}, uniforms, {\n        extruded: Boolean(extruded),\n        elevationScale: elevationScale\n      });\n\n      if (sideModel) {\n        sideModel.setInstanceCount(polygonTesselator.instanceCount - 1);\n        sideModel.setUniforms(renderUniforms);\n\n        if (wireframe) {\n          sideModel.setDrawMode(3);\n          sideModel.setUniforms({\n            isWireframe: true\n          }).draw();\n        }\n\n        if (filled) {\n          sideModel.setDrawMode(6);\n          sideModel.setUniforms({\n            isWireframe: false\n          }).draw();\n        }\n      }\n\n      if (topModel) {\n        topModel.setVertexCount(polygonTesselator.vertexCount);\n        topModel.setUniforms(renderUniforms).draw();\n      }\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(updateParams) {\n      _get(_getPrototypeOf(SolidPolygonLayer.prototype), \"updateState\", this).call(this, updateParams);\n\n      this.updateGeometry(updateParams);\n      var props = updateParams.props,\n          oldProps = updateParams.oldProps,\n          changeFlags = updateParams.changeFlags;\n      var attributeManager = this.getAttributeManager();\n      var regenerateModels = changeFlags.extensionsChanged || props.filled !== oldProps.filled || props.extruded !== oldProps.extruded;\n\n      if (regenerateModels) {\n        if (this.state.models) {\n          this.state.models.forEach(function (model) {\n            return model[\"delete\"]();\n          });\n        }\n\n        this.setState(this._getModels(this.context.gl));\n        attributeManager.invalidateAll();\n      }\n    }\n  }, {\n    key: \"updateGeometry\",\n    value: function updateGeometry(_ref3) {\n      var props = _ref3.props,\n          oldProps = _ref3.oldProps,\n          changeFlags = _ref3.changeFlags;\n      var geometryConfigChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPolygon);\n\n      if (geometryConfigChanged) {\n        var polygonTesselator = this.state.polygonTesselator;\n        var buffers = props.data.attributes || {};\n        polygonTesselator.updateGeometry({\n          data: props.data,\n          normalize: props._normalize,\n          geometryBuffer: buffers.getPolygon,\n          buffers: buffers,\n          getGeometry: props.getPolygon,\n          positionFormat: props.positionFormat,\n          wrapLongitude: props.wrapLongitude,\n          resolution: this.context.viewport.resolution,\n          fp64: this.use64bitPositions(),\n          dataChanged: changeFlags.dataChanged\n        });\n        this.setState({\n          numInstances: polygonTesselator.instanceCount,\n          startIndices: polygonTesselator.vertexStarts\n        });\n\n        if (!changeFlags.dataChanged) {\n          this.getAttributeManager().invalidateAll();\n        }\n      }\n    }\n  }, {\n    key: \"_getModels\",\n    value: function _getModels(gl) {\n      var _this$props2 = this.props,\n          id = _this$props2.id,\n          filled = _this$props2.filled,\n          extruded = _this$props2.extruded;\n      var topModel;\n      var sideModel;\n\n      if (filled) {\n        var shaders = this.getShaders(vsTop);\n        shaders.defines.NON_INSTANCED_MODEL = 1;\n        topModel = new Model(gl, Object.assign({}, shaders, {\n          id: \"\".concat(id, \"-top\"),\n          drawMode: 4,\n          attributes: {\n            vertexPositions: new Float32Array([0, 1])\n          },\n          uniforms: {\n            isWireframe: false,\n            isSideVertex: false\n          },\n          vertexCount: 0,\n          isIndexed: true\n        }));\n      }\n\n      if (extruded) {\n        sideModel = new Model(gl, Object.assign({}, this.getShaders(vsSide), {\n          id: \"\".concat(id, \"-side\"),\n          geometry: new Geometry({\n            drawMode: 1,\n            vertexCount: 4,\n            attributes: {\n              vertexPositions: {\n                size: 2,\n                value: new Float32Array([1, 0, 0, 0, 0, 1, 1, 1])\n              }\n            }\n          }),\n          instanceCount: 0,\n          isInstanced: 1\n        }));\n        sideModel.userData.excludeAttributes = {\n          indices: true\n        };\n      }\n\n      return {\n        models: [sideModel, topModel].filter(Boolean),\n        topModel: topModel,\n        sideModel: sideModel\n      };\n    }\n  }, {\n    key: \"calculateIndices\",\n    value: function calculateIndices(attribute) {\n      var polygonTesselator = this.state.polygonTesselator;\n      attribute.startIndices = polygonTesselator.indexStarts;\n      attribute.value = polygonTesselator.get('indices');\n    }\n  }, {\n    key: \"calculatePositions\",\n    value: function calculatePositions(attribute) {\n      var polygonTesselator = this.state.polygonTesselator;\n      attribute.startIndices = polygonTesselator.vertexStarts;\n      attribute.value = polygonTesselator.get('positions');\n    }\n  }, {\n    key: \"calculateVertexValid\",\n    value: function calculateVertexValid(attribute) {\n      attribute.value = this.state.polygonTesselator.get('vertexValid');\n    }\n  }, {\n    key: \"wrapLongitude\",\n    get: function get() {\n      return false;\n    }\n  }]);\n\n  return SolidPolygonLayer;\n}(Layer);\n\nexport { SolidPolygonLayer as default };\nSolidPolygonLayer.layerName = 'SolidPolygonLayer';\nSolidPolygonLayer.defaultProps = defaultProps;","export default \"#define SHADER_NAME solid-polygon-layer-fragment-shader\\n\\nprecision highp float;\\n\\nvarying vec4 vColor;\\nvarying float isValid;\\n\\nvoid main(void) {\\n  if (isValid < 0.5) {\\n    discard;\\n  }\\n\\n  gl_FragColor = vColor;\\n\\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\\n}\\n\";","import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"@babel/runtime/helpers/esm/get\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport Layer from './layer';\nimport debug from '../debug';\nimport { flatten } from '../utils/flatten';\nvar TRACE_RENDER_LAYERS = 'compositeLayer.renderLayers';\n\nvar CompositeLayer = function (_Layer) {\n  _inherits(CompositeLayer, _Layer);\n\n  function CompositeLayer() {\n    _classCallCheck(this, CompositeLayer);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(CompositeLayer).apply(this, arguments));\n  }\n\n  _createClass(CompositeLayer, [{\n    key: \"getSubLayers\",\n    value: function getSubLayers() {\n      return this.internalState && this.internalState.subLayers || [];\n    }\n  }, {\n    key: \"initializeState\",\n    value: function initializeState() {}\n  }, {\n    key: \"setState\",\n    value: function setState(updateObject) {\n      _get(_getPrototypeOf(CompositeLayer.prototype), \"setState\", this).call(this, updateObject);\n\n      this.setNeedsUpdate();\n    }\n  }, {\n    key: \"getPickingInfo\",\n    value: function getPickingInfo(_ref) {\n      var info = _ref.info;\n      var object = info.object;\n      var isDataWrapped = object && object.__source && object.__source.parent && object.__source.parent.id === this.id;\n\n      if (!isDataWrapped) {\n        return info;\n      }\n\n      return Object.assign(info, {\n        object: object.__source.object,\n        index: object.__source.index\n      });\n    }\n  }, {\n    key: \"renderLayers\",\n    value: function renderLayers() {\n      return null;\n    }\n  }, {\n    key: \"shouldRenderSubLayer\",\n    value: function shouldRenderSubLayer(id, data) {\n      var overridingProps = this.props._subLayerProps;\n      return data && data.length || overridingProps && overridingProps[id];\n    }\n  }, {\n    key: \"getSubLayerClass\",\n    value: function getSubLayerClass(id, DefaultLayerClass) {\n      var overridingProps = this.props._subLayerProps;\n      return overridingProps && overridingProps[id] && overridingProps[id].type || DefaultLayerClass;\n    }\n  }, {\n    key: \"getSubLayerRow\",\n    value: function getSubLayerRow(row, sourceObject, sourceObjectIndex) {\n      row.__source = {\n        parent: this,\n        object: sourceObject,\n        index: sourceObjectIndex\n      };\n      return row;\n    }\n  }, {\n    key: \"getSubLayerAccessor\",\n    value: function getSubLayerAccessor(accessor) {\n      if (typeof accessor === 'function') {\n        var objectInfo = {\n          data: this.props.data,\n          target: []\n        };\n        return function (x, i) {\n          if (x.__source) {\n            objectInfo.index = x.__source.index;\n            return accessor(x.__source.object, objectInfo);\n          }\n\n          return accessor(x, i);\n        };\n      }\n\n      return accessor;\n    }\n  }, {\n    key: \"getSubLayerProps\",\n    value: function getSubLayerProps() {\n      var sublayerProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var _this$props = this.props,\n          opacity = _this$props.opacity,\n          pickable = _this$props.pickable,\n          visible = _this$props.visible,\n          parameters = _this$props.parameters,\n          getPolygonOffset = _this$props.getPolygonOffset,\n          highlightedObjectIndex = _this$props.highlightedObjectIndex,\n          autoHighlight = _this$props.autoHighlight,\n          highlightColor = _this$props.highlightColor,\n          coordinateSystem = _this$props.coordinateSystem,\n          coordinateOrigin = _this$props.coordinateOrigin,\n          wrapLongitude = _this$props.wrapLongitude,\n          positionFormat = _this$props.positionFormat,\n          modelMatrix = _this$props.modelMatrix,\n          extensions = _this$props.extensions,\n          overridingProps = _this$props._subLayerProps;\n      var newProps = {\n        opacity: opacity,\n        pickable: pickable,\n        visible: visible,\n        parameters: parameters,\n        getPolygonOffset: getPolygonOffset,\n        highlightedObjectIndex: highlightedObjectIndex,\n        autoHighlight: autoHighlight,\n        highlightColor: highlightColor,\n        coordinateSystem: coordinateSystem,\n        coordinateOrigin: coordinateOrigin,\n        wrapLongitude: wrapLongitude,\n        positionFormat: positionFormat,\n        modelMatrix: modelMatrix,\n        extensions: extensions\n      };\n      var overridingSublayerProps = overridingProps && overridingProps[sublayerProps.id];\n      var overridingSublayerTriggers = overridingSublayerProps && overridingSublayerProps.updateTriggers;\n      var sublayerId = sublayerProps.id || 'sublayer';\n\n      if (overridingSublayerProps) {\n        var propTypes = this.constructor._propTypes;\n\n        for (var key in overridingSublayerProps) {\n          var propType = propTypes[key];\n\n          if (propType && propType.type === 'accessor') {\n            overridingSublayerProps[key] = this.getSubLayerAccessor(overridingSublayerProps[key]);\n          }\n        }\n      }\n\n      Object.assign(newProps, sublayerProps, overridingSublayerProps, {\n        id: \"\".concat(this.props.id, \"-\").concat(sublayerId),\n        updateTriggers: Object.assign({\n          all: this.props.updateTriggers.all\n        }, sublayerProps.updateTriggers, overridingSublayerTriggers)\n      });\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = extensions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var extension = _step.value;\n          var passThroughProps = extension.getSubLayerProps.call(this, extension);\n\n          if (passThroughProps) {\n            Object.assign(newProps, passThroughProps, {\n              updateTriggers: Object.assign(newProps.updateTriggers, passThroughProps.updateTriggers)\n            });\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n            _iterator[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return newProps;\n    }\n  }, {\n    key: \"_getAttributeManager\",\n    value: function _getAttributeManager() {\n      return null;\n    }\n  }, {\n    key: \"_renderLayers\",\n    value: function _renderLayers() {\n      var subLayers = this.internalState.subLayers;\n      var shouldUpdate = !subLayers || this.needsUpdate();\n\n      if (shouldUpdate) {\n        subLayers = this.renderLayers();\n        subLayers = flatten(subLayers, Boolean);\n        this.internalState.subLayers = subLayers;\n      }\n\n      debug(TRACE_RENDER_LAYERS, this, shouldUpdate, subLayers);\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = subLayers[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var layer = _step2.value;\n          layer.parent = this;\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n            _iterator2[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"isComposite\",\n    get: function get() {\n      return true;\n    }\n  }, {\n    key: \"isLoaded\",\n    get: function get() {\n      return _get(_getPrototypeOf(CompositeLayer.prototype), \"isLoaded\", this) && this.getSubLayers().every(function (layer) {\n        return layer.isLoaded;\n      });\n    }\n  }]);\n\n  return CompositeLayer;\n}(Layer);\n\nexport { CompositeLayer as default };\nCompositeLayer.layerName = 'CompositeLayer';","export function replaceInRange(_ref) {\n  var data = _ref.data,\n      getIndex = _ref.getIndex,\n      dataRange = _ref.dataRange,\n      replace = _ref.replace;\n  var _dataRange$startRow = dataRange.startRow,\n      startRow = _dataRange$startRow === void 0 ? 0 : _dataRange$startRow,\n      _dataRange$endRow = dataRange.endRow,\n      endRow = _dataRange$endRow === void 0 ? Infinity : _dataRange$endRow;\n  var count = data.length;\n  var replaceStart = count;\n  var replaceEnd = count;\n\n  for (var i = 0; i < count; i++) {\n    var row = getIndex(data[i]);\n\n    if (replaceStart > i && row >= startRow) {\n      replaceStart = i;\n    }\n\n    if (row >= endRow) {\n      replaceEnd = i;\n      break;\n    }\n  }\n\n  var index = replaceStart;\n  var dataLengthChanged = replaceEnd - replaceStart !== replace.length;\n  var endChunk = dataLengthChanged && data.slice(replaceEnd);\n\n  for (var _i = 0; _i < replace.length; _i++) {\n    data[index++] = replace[_i];\n  }\n\n  if (dataLengthChanged) {\n    for (var _i2 = 0; _i2 < endChunk.length; _i2++) {\n      data[index++] = endChunk[_i2];\n    }\n\n    data.length = index;\n  }\n\n  return {\n    startRow: replaceStart,\n    endRow: replaceStart + replace.length\n  };\n}","export default \"\\nuniform float lighting_uAmbient;\\nuniform float lighting_uDiffuse;\\nuniform float lighting_uShininess;\\nuniform vec3  lighting_uSpecularColor;\\n\\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {\\n    vec3 halfway_direction = normalize(light_direction + view_direction);\\n    float lambertian = dot(light_direction, normal_worldspace);\\n    float specular = 0.0;\\n    if (lambertian > 0.0) {\\n      float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);\\n      specular = pow(specular_angle, lighting_uShininess);\\n    }\\n    lambertian = max(lambertian, 0.0);\\n    return (lambertian * lighting_uDiffuse * surfaceColor + specular * lighting_uSpecularColor) * color;\\n}\\n\\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\\n  vec3 lightColor = surfaceColor;\\n\\n  if (lighting_uEnabled) {\\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\\n    lightColor = lighting_uAmbient * surfaceColor * lighting_uAmbientLight.color;\\n\\n    for (int i = 0; i < MAX_LIGHTS; i++) {\\n      if (i >= lighting_uPointLightCount) {\\n        break;\\n      }\\n      PointLight pointLight = lighting_uPointLight[i];\\n      vec3 light_position_worldspace = pointLight.position;\\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\\n    }\\n\\n    for (int i = 0; i < MAX_LIGHTS; i++) {\\n      if (i >= lighting_uDirectionalLightCount) {\\n        break;\\n      }\\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\\n    }\\n  }\\n  return lightColor;\\n}\\n\\nvec3 lighting_getSpecularLightColor(vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\\n  vec3 lightColor = vec3(0, 0, 0);\\n  vec3 surfaceColor = vec3(0, 0, 0);\\n\\n  if (lighting_uEnabled) {\\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\\n\\n    for (int i = 0; i < MAX_LIGHTS; i++) {\\n      if (i >= lighting_uPointLightCount) {\\n        break;\\n      }\\n      PointLight pointLight = lighting_uPointLight[i];\\n      vec3 light_position_worldspace = pointLight.position;\\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\\n    }\\n\\n    for (int i = 0; i < MAX_LIGHTS; i++) {\\n      if (i >= lighting_uDirectionalLightCount) {\\n        break;\\n      }\\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\\n    }\\n  }\\n  return lightColor;\\n}\\n\";","import lights from '../lights/lights';\nimport lightingShader from './phong-lighting.glsl';\nvar gouraudLighting = {\n  name: 'gouraud-lighting',\n  dependencies: [lights],\n  vs: lightingShader,\n  defines: {\n    LIGHTING_VERTEX: 1\n  },\n  getUniforms: getUniforms\n};\nvar phongLighting = {\n  name: 'phong-lighting',\n  dependencies: [lights],\n  fs: lightingShader,\n  defines: {\n    LIGHTING_FRAGMENT: 1\n  },\n  getUniforms: getUniforms\n};\nvar INITIAL_MODULE_OPTIONS = {};\n\nfunction getMaterialUniforms(material) {\n  var _material$ambient = material.ambient,\n      ambient = _material$ambient === void 0 ? 0.35 : _material$ambient,\n      _material$diffuse = material.diffuse,\n      diffuse = _material$diffuse === void 0 ? 0.6 : _material$diffuse,\n      _material$shininess = material.shininess,\n      shininess = _material$shininess === void 0 ? 32 : _material$shininess,\n      _material$specularCol = material.specularColor,\n      specularColor = _material$specularCol === void 0 ? [30, 30, 30] : _material$specularCol;\n  return {\n    lighting_uAmbient: ambient,\n    lighting_uDiffuse: diffuse,\n    lighting_uShininess: shininess,\n    lighting_uSpecularColor: specularColor.map(function (x) {\n      return x / 255;\n    })\n  };\n}\n\nfunction getUniforms() {\n  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : INITIAL_MODULE_OPTIONS;\n\n  if (!('material' in opts)) {\n    return {};\n  }\n\n  var material = opts.material;\n\n  if (!material) {\n    return {\n      lighting_uEnabled: false\n    };\n  }\n\n  return getMaterialUniforms(material);\n}\n\nexport { gouraudLighting, phongLighting };","import earcut from 'earcut';\n\nfunction validate(polygon) {\n  polygon = polygon && polygon.positions || polygon;\n\n  if (!Array.isArray(polygon) && !ArrayBuffer.isView(polygon)) {\n    throw new Error('invalid polygon');\n  }\n}\n\nfunction isSimple(polygon) {\n  return polygon.length >= 1 && polygon[0].length >= 2 && Number.isFinite(polygon[0][0]);\n}\n\nfunction isNestedRingClosed(simplePolygon) {\n  var p0 = simplePolygon[0];\n  var p1 = simplePolygon[simplePolygon.length - 1];\n  return p0[0] === p1[0] && p0[1] === p1[1] && p0[2] === p1[2];\n}\n\nfunction isFlatRingClosed(positions, size, startIndex, endIndex) {\n  for (var i = 0; i < size; i++) {\n    if (positions[startIndex + i] !== positions[endIndex - size + i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction copyNestedRing(target, targetStartIndex, simplePolygon, size) {\n  var targetIndex = targetStartIndex;\n  var len = simplePolygon.length;\n\n  for (var i = 0; i < len; i++) {\n    for (var j = 0; j < size; j++) {\n      target[targetIndex++] = simplePolygon[i][j] || 0;\n    }\n  }\n\n  if (!isNestedRingClosed(simplePolygon)) {\n    for (var _j = 0; _j < size; _j++) {\n      target[targetIndex++] = simplePolygon[0][_j] || 0;\n    }\n  }\n\n  return targetIndex;\n}\n\nfunction copyFlatRing(target, targetStartIndex, positions, size) {\n  var srcStartIndex = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n  var srcEndIndex = arguments.length > 5 ? arguments[5] : undefined;\n  srcEndIndex = srcEndIndex || positions.length;\n  var srcLength = srcEndIndex - srcStartIndex;\n\n  if (srcLength <= 0) {\n    return targetStartIndex;\n  }\n\n  var targetIndex = targetStartIndex;\n\n  for (var i = 0; i < srcLength; i++) {\n    target[targetIndex++] = positions[srcStartIndex + i];\n  }\n\n  if (!isFlatRingClosed(positions, size, srcStartIndex, srcEndIndex)) {\n    for (var _i = 0; _i < size; _i++) {\n      target[targetIndex++] = positions[srcStartIndex + _i];\n    }\n  }\n\n  return targetIndex;\n}\n\nexport function normalize(polygon, positionSize) {\n  validate(polygon);\n  var positions = [];\n  var holeIndices = [];\n\n  if (polygon.positions) {\n    var _polygon = polygon,\n        srcPositions = _polygon.positions,\n        srcHoleIndices = _polygon.holeIndices;\n\n    if (srcHoleIndices) {\n      var targetIndex = 0;\n\n      for (var i = 0; i <= srcHoleIndices.length; i++) {\n        targetIndex = copyFlatRing(positions, targetIndex, srcPositions, positionSize, srcHoleIndices[i - 1], srcHoleIndices[i]);\n        holeIndices.push(targetIndex);\n      }\n\n      holeIndices.pop();\n      return {\n        positions: positions,\n        holeIndices: holeIndices\n      };\n    }\n\n    polygon = srcPositions;\n  }\n\n  if (Number.isFinite(polygon[0])) {\n    copyFlatRing(positions, 0, polygon, positionSize);\n    return positions;\n  }\n\n  if (!isSimple(polygon)) {\n    var _targetIndex = 0;\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = polygon[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var simplePolygon = _step.value;\n        _targetIndex = copyNestedRing(positions, _targetIndex, simplePolygon, positionSize);\n        holeIndices.push(_targetIndex);\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n          _iterator[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    holeIndices.pop();\n    return {\n      positions: positions,\n      holeIndices: holeIndices\n    };\n  }\n\n  copyNestedRing(positions, 0, polygon, positionSize);\n  return positions;\n}\nexport function getSurfaceIndices(normalizedPolygon, positionSize, preproject) {\n  var holeIndices = null;\n\n  if (normalizedPolygon.holeIndices) {\n    holeIndices = normalizedPolygon.holeIndices.map(function (positionIndex) {\n      return positionIndex / positionSize;\n    });\n  }\n\n  var positions = normalizedPolygon.positions || normalizedPolygon;\n\n  if (preproject) {\n    var n = positions.length;\n    positions = positions.slice();\n    var p = [];\n\n    for (var i = 0; i < n; i += positionSize) {\n      p[0] = positions[i];\n      p[1] = positions[i + 1];\n      var xy = preproject(p);\n      positions[i] = xy[0];\n      positions[i + 1] = xy[1];\n    }\n  }\n\n  return earcut(positions, holeIndices, positionSize);\n}","'use strict';\n\nmodule.exports = earcut;\nmodule.exports.default = earcut;\n\nfunction earcut(data, holeIndices, dim) {\n  dim = dim || 2;\n  var hasHoles = holeIndices && holeIndices.length,\n      outerLen = hasHoles ? holeIndices[0] * dim : data.length,\n      outerNode = linkedList(data, 0, outerLen, dim, true),\n      triangles = [];\n  if (!outerNode || outerNode.next === outerNode.prev) return triangles;\n  var minX, minY, maxX, maxY, x, y, invSize;\n  if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim); // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n\n  if (data.length > 80 * dim) {\n    minX = maxX = data[0];\n    minY = maxY = data[1];\n\n    for (var i = dim; i < outerLen; i += dim) {\n      x = data[i];\n      y = data[i + 1];\n      if (x < minX) minX = x;\n      if (y < minY) minY = y;\n      if (x > maxX) maxX = x;\n      if (y > maxY) maxY = y;\n    } // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n\n\n    invSize = Math.max(maxX - minX, maxY - minY);\n    invSize = invSize !== 0 ? 1 / invSize : 0;\n  }\n\n  earcutLinked(outerNode, triangles, dim, minX, minY, invSize);\n  return triangles;\n} // create a circular doubly linked list from polygon points in the specified winding order\n\n\nfunction linkedList(data, start, end, dim, clockwise) {\n  var i, last;\n\n  if (clockwise === signedArea(data, start, end, dim) > 0) {\n    for (i = start; i < end; i += dim) {\n      last = insertNode(i, data[i], data[i + 1], last);\n    }\n  } else {\n    for (i = end - dim; i >= start; i -= dim) {\n      last = insertNode(i, data[i], data[i + 1], last);\n    }\n  }\n\n  if (last && equals(last, last.next)) {\n    removeNode(last);\n    last = last.next;\n  }\n\n  return last;\n} // eliminate colinear or duplicate points\n\n\nfunction filterPoints(start, end) {\n  if (!start) return start;\n  if (!end) end = start;\n  var p = start,\n      again;\n\n  do {\n    again = false;\n\n    if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n      removeNode(p);\n      p = end = p.prev;\n      if (p === p.next) break;\n      again = true;\n    } else {\n      p = p.next;\n    }\n  } while (again || p !== end);\n\n  return end;\n} // main ear slicing loop which triangulates a polygon (given as a linked list)\n\n\nfunction earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n  if (!ear) return; // interlink polygon nodes in z-order\n\n  if (!pass && invSize) indexCurve(ear, minX, minY, invSize);\n  var stop = ear,\n      prev,\n      next; // iterate through ears, slicing them one by one\n\n  while (ear.prev !== ear.next) {\n    prev = ear.prev;\n    next = ear.next;\n\n    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n      // cut off the triangle\n      triangles.push(prev.i / dim);\n      triangles.push(ear.i / dim);\n      triangles.push(next.i / dim);\n      removeNode(ear); // skipping the next vertex leads to less sliver triangles\n\n      ear = next.next;\n      stop = next.next;\n      continue;\n    }\n\n    ear = next; // if we looped through the whole remaining polygon and can't find any more ears\n\n    if (ear === stop) {\n      // try filtering points and slicing again\n      if (!pass) {\n        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1); // if this didn't work, try curing all small self-intersections locally\n      } else if (pass === 1) {\n        ear = cureLocalIntersections(filterPoints(ear), triangles, dim);\n        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2); // as a last resort, try splitting the remaining polygon into two\n      } else if (pass === 2) {\n        splitEarcut(ear, triangles, dim, minX, minY, invSize);\n      }\n\n      break;\n    }\n  }\n} // check whether a polygon node forms a valid ear with adjacent nodes\n\n\nfunction isEar(ear) {\n  var a = ear.prev,\n      b = ear,\n      c = ear.next;\n  if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n  // now make sure we don't have other points inside the potential ear\n\n  var p = ear.next.next;\n\n  while (p !== ear.prev) {\n    if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n    p = p.next;\n  }\n\n  return true;\n}\n\nfunction isEarHashed(ear, minX, minY, invSize) {\n  var a = ear.prev,\n      b = ear,\n      c = ear.next;\n  if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n  // triangle bbox; min & max are calculated like this for speed\n\n  var minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x,\n      minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y,\n      maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x,\n      maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y; // z-order range for the current triangle bbox;\n\n  var minZ = zOrder(minTX, minTY, minX, minY, invSize),\n      maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);\n  var p = ear.prevZ,\n      n = ear.nextZ; // look for points inside the triangle in both directions\n\n  while (p && p.z >= minZ && n && n.z <= maxZ) {\n    if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n    p = p.prevZ;\n    if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n    n = n.nextZ;\n  } // look for remaining points in decreasing z-order\n\n\n  while (p && p.z >= minZ) {\n    if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n    p = p.prevZ;\n  } // look for remaining points in increasing z-order\n\n\n  while (n && n.z <= maxZ) {\n    if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n    n = n.nextZ;\n  }\n\n  return true;\n} // go through all polygon nodes and cure small local self-intersections\n\n\nfunction cureLocalIntersections(start, triangles, dim) {\n  var p = start;\n\n  do {\n    var a = p.prev,\n        b = p.next.next;\n\n    if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n      triangles.push(a.i / dim);\n      triangles.push(p.i / dim);\n      triangles.push(b.i / dim); // remove two nodes involved\n\n      removeNode(p);\n      removeNode(p.next);\n      p = start = b;\n    }\n\n    p = p.next;\n  } while (p !== start);\n\n  return filterPoints(p);\n} // try splitting polygon into two and triangulate them independently\n\n\nfunction splitEarcut(start, triangles, dim, minX, minY, invSize) {\n  // look for a valid diagonal that divides the polygon into two\n  var a = start;\n\n  do {\n    var b = a.next.next;\n\n    while (b !== a.prev) {\n      if (a.i !== b.i && isValidDiagonal(a, b)) {\n        // split the polygon in two by the diagonal\n        var c = splitPolygon(a, b); // filter colinear points around the cuts\n\n        a = filterPoints(a, a.next);\n        c = filterPoints(c, c.next); // run earcut on each half\n\n        earcutLinked(a, triangles, dim, minX, minY, invSize);\n        earcutLinked(c, triangles, dim, minX, minY, invSize);\n        return;\n      }\n\n      b = b.next;\n    }\n\n    a = a.next;\n  } while (a !== start);\n} // link every hole into the outer loop, producing a single-ring polygon without holes\n\n\nfunction eliminateHoles(data, holeIndices, outerNode, dim) {\n  var queue = [],\n      i,\n      len,\n      start,\n      end,\n      list;\n\n  for (i = 0, len = holeIndices.length; i < len; i++) {\n    start = holeIndices[i] * dim;\n    end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n    list = linkedList(data, start, end, dim, false);\n    if (list === list.next) list.steiner = true;\n    queue.push(getLeftmost(list));\n  }\n\n  queue.sort(compareX); // process holes from left to right\n\n  for (i = 0; i < queue.length; i++) {\n    eliminateHole(queue[i], outerNode);\n    outerNode = filterPoints(outerNode, outerNode.next);\n  }\n\n  return outerNode;\n}\n\nfunction compareX(a, b) {\n  return a.x - b.x;\n} // find a bridge between vertices that connects hole with an outer ring and and link it\n\n\nfunction eliminateHole(hole, outerNode) {\n  outerNode = findHoleBridge(hole, outerNode);\n\n  if (outerNode) {\n    var b = splitPolygon(outerNode, hole); // filter collinear points around the cuts\n\n    filterPoints(outerNode, outerNode.next);\n    filterPoints(b, b.next);\n  }\n} // David Eberly's algorithm for finding a bridge between hole and outer polygon\n\n\nfunction findHoleBridge(hole, outerNode) {\n  var p = outerNode,\n      hx = hole.x,\n      hy = hole.y,\n      qx = -Infinity,\n      m; // find a segment intersected by a ray from the hole's leftmost point to the left;\n  // segment's endpoint with lesser x will be potential connection point\n\n  do {\n    if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n      var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n\n      if (x <= hx && x > qx) {\n        qx = x;\n\n        if (x === hx) {\n          if (hy === p.y) return p;\n          if (hy === p.next.y) return p.next;\n        }\n\n        m = p.x < p.next.x ? p : p.next;\n      }\n    }\n\n    p = p.next;\n  } while (p !== outerNode);\n\n  if (!m) return null;\n  if (hx === qx) return m; // hole touches outer segment; pick leftmost endpoint\n  // look for points inside the triangle of hole point, segment intersection and endpoint;\n  // if there are no points found, we have a valid connection;\n  // otherwise choose the point of the minimum angle with the ray as connection point\n\n  var stop = m,\n      mx = m.x,\n      my = m.y,\n      tanMin = Infinity,\n      tan;\n  p = m;\n\n  do {\n    if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n      tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n      if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {\n        m = p;\n        tanMin = tan;\n      }\n    }\n\n    p = p.next;\n  } while (p !== stop);\n\n  return m;\n} // whether sector in vertex m contains sector in vertex p in the same coordinates\n\n\nfunction sectorContainsSector(m, p) {\n  return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;\n} // interlink polygon nodes in z-order\n\n\nfunction indexCurve(start, minX, minY, invSize) {\n  var p = start;\n\n  do {\n    if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);\n    p.prevZ = p.prev;\n    p.nextZ = p.next;\n    p = p.next;\n  } while (p !== start);\n\n  p.prevZ.nextZ = null;\n  p.prevZ = null;\n  sortLinked(p);\n} // Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\n\n\nfunction sortLinked(list) {\n  var i,\n      p,\n      q,\n      e,\n      tail,\n      numMerges,\n      pSize,\n      qSize,\n      inSize = 1;\n\n  do {\n    p = list;\n    list = null;\n    tail = null;\n    numMerges = 0;\n\n    while (p) {\n      numMerges++;\n      q = p;\n      pSize = 0;\n\n      for (i = 0; i < inSize; i++) {\n        pSize++;\n        q = q.nextZ;\n        if (!q) break;\n      }\n\n      qSize = inSize;\n\n      while (pSize > 0 || qSize > 0 && q) {\n        if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n          e = p;\n          p = p.nextZ;\n          pSize--;\n        } else {\n          e = q;\n          q = q.nextZ;\n          qSize--;\n        }\n\n        if (tail) tail.nextZ = e;else list = e;\n        e.prevZ = tail;\n        tail = e;\n      }\n\n      p = q;\n    }\n\n    tail.nextZ = null;\n    inSize *= 2;\n  } while (numMerges > 1);\n\n  return list;\n} // z-order of a point given coords and inverse of the longer side of data bbox\n\n\nfunction zOrder(x, y, minX, minY, invSize) {\n  // coords are transformed into non-negative 15-bit integer range\n  x = 32767 * (x - minX) * invSize;\n  y = 32767 * (y - minY) * invSize;\n  x = (x | x << 8) & 0x00FF00FF;\n  x = (x | x << 4) & 0x0F0F0F0F;\n  x = (x | x << 2) & 0x33333333;\n  x = (x | x << 1) & 0x55555555;\n  y = (y | y << 8) & 0x00FF00FF;\n  y = (y | y << 4) & 0x0F0F0F0F;\n  y = (y | y << 2) & 0x33333333;\n  y = (y | y << 1) & 0x55555555;\n  return x | y << 1;\n} // find the leftmost node of a polygon ring\n\n\nfunction getLeftmost(start) {\n  var p = start,\n      leftmost = start;\n\n  do {\n    if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;\n    p = p.next;\n  } while (p !== start);\n\n  return leftmost;\n} // check if a point lies within a convex triangle\n\n\nfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n  return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;\n} // check if a diagonal between two polygon nodes is valid (lies in polygon interior)\n\n\nfunction isValidDiagonal(a, b) {\n  return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && ( // dones't intersect other edges\n  locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && ( // locally visible\n  area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors\n  equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case\n} // signed area of a triangle\n\n\nfunction area(p, q, r) {\n  return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n} // check if two points are equal\n\n\nfunction equals(p1, p2) {\n  return p1.x === p2.x && p1.y === p2.y;\n} // check if two segments intersect\n\n\nfunction intersects(p1, q1, p2, q2) {\n  var o1 = sign(area(p1, q1, p2));\n  var o2 = sign(area(p1, q1, q2));\n  var o3 = sign(area(p2, q2, p1));\n  var o4 = sign(area(p2, q2, q1));\n  if (o1 !== o2 && o3 !== o4) return true; // general case\n\n  if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n\n  if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n\n  if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n\n  if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n\n  return false;\n} // for collinear points p, q, r, check if point q lies on segment pr\n\n\nfunction onSegment(p, q, r) {\n  return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);\n}\n\nfunction sign(num) {\n  return num > 0 ? 1 : num < 0 ? -1 : 0;\n} // check if a polygon diagonal intersects any polygon segments\n\n\nfunction intersectsPolygon(a, b) {\n  var p = a;\n\n  do {\n    if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;\n    p = p.next;\n  } while (p !== a);\n\n  return false;\n} // check if a polygon diagonal is locally inside the polygon\n\n\nfunction locallyInside(a, b) {\n  return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n} // check if the middle point of a polygon diagonal is inside the polygon\n\n\nfunction middleInside(a, b) {\n  var p = a,\n      inside = false,\n      px = (a.x + b.x) / 2,\n      py = (a.y + b.y) / 2;\n\n  do {\n    if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;\n    p = p.next;\n  } while (p !== a);\n\n  return inside;\n} // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\n\n\nfunction splitPolygon(a, b) {\n  var a2 = new Node(a.i, a.x, a.y),\n      b2 = new Node(b.i, b.x, b.y),\n      an = a.next,\n      bp = b.prev;\n  a.next = b;\n  b.prev = a;\n  a2.next = an;\n  an.prev = a2;\n  b2.next = a2;\n  a2.prev = b2;\n  bp.next = b2;\n  b2.prev = bp;\n  return b2;\n} // create a node and optionally link it with previous one (in a circular doubly linked list)\n\n\nfunction insertNode(i, x, y, last) {\n  var p = new Node(i, x, y);\n\n  if (!last) {\n    p.prev = p;\n    p.next = p;\n  } else {\n    p.next = last.next;\n    p.prev = last;\n    last.next.prev = p;\n    last.next = p;\n  }\n\n  return p;\n}\n\nfunction removeNode(p) {\n  p.next.prev = p.prev;\n  p.prev.next = p.next;\n  if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n  if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\n\nfunction Node(i, x, y) {\n  // vertex index in coordinates array\n  this.i = i; // vertex coordinates\n\n  this.x = x;\n  this.y = y; // previous and next vertex nodes in a polygon ring\n\n  this.prev = null;\n  this.next = null; // z-order curve value\n\n  this.z = null; // previous and next nodes in z-order\n\n  this.prevZ = null;\n  this.nextZ = null; // indicates whether this is a steiner point\n\n  this.steiner = false;\n} // return a percentage difference between the polygon area and its triangulation area;\n// used to verify correctness of triangulation\n\n\nearcut.deviation = function (data, holeIndices, dim, triangles) {\n  var hasHoles = holeIndices && holeIndices.length;\n  var outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n  var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));\n\n  if (hasHoles) {\n    for (var i = 0, len = holeIndices.length; i < len; i++) {\n      var start = holeIndices[i] * dim;\n      var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n      polygonArea -= Math.abs(signedArea(data, start, end, dim));\n    }\n  }\n\n  var trianglesArea = 0;\n\n  for (i = 0; i < triangles.length; i += 3) {\n    var a = triangles[i] * dim;\n    var b = triangles[i + 1] * dim;\n    var c = triangles[i + 2] * dim;\n    trianglesArea += Math.abs((data[a] - data[c]) * (data[b + 1] - data[a + 1]) - (data[a] - data[b]) * (data[c + 1] - data[a + 1]));\n  }\n\n  return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);\n};\n\nfunction signedArea(data, start, end, dim) {\n  var sum = 0;\n\n  for (var i = start, j = end - dim; i < end; i += dim) {\n    sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n    j = i;\n  }\n\n  return sum;\n} // turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts\n\n\nearcut.flatten = function (data) {\n  var dim = data[0][0].length,\n      result = {\n    vertices: [],\n    holes: [],\n    dimensions: dim\n  },\n      holeIndex = 0;\n\n  for (var i = 0; i < data.length; i++) {\n    for (var j = 0; j < data[i].length; j++) {\n      for (var d = 0; d < dim; d++) {\n        result.vertices.push(data[i][j][d]);\n      }\n    }\n\n    if (i > 0) {\n      holeIndex += data[i - 1].length;\n      result.holes.push(holeIndex);\n    }\n  }\n\n  return result;\n};","import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport { createIterable, getAccessorFromBuffer } from './iterable-utils';\nimport defaultTypedArrayManager from './typed-array-manager';\nimport assert from './assert';\nimport { Buffer } from '@luma.gl/core';\n\nvar Tesselator = function () {\n  function Tesselator() {\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Tesselator);\n\n    var _opts$attributes = opts.attributes,\n        attributes = _opts$attributes === void 0 ? {} : _opts$attributes;\n    this.typedArrayManager = defaultTypedArrayManager;\n    this.indexStarts = null;\n    this.vertexStarts = null;\n    this.vertexCount = 0;\n    this.instanceCount = 0;\n    this.attributes = {};\n    this._attributeDefs = attributes;\n    this.opts = opts;\n    this.updateGeometry(opts);\n    Object.seal(this);\n  }\n\n  _createClass(Tesselator, [{\n    key: \"updateGeometry\",\n    value: function updateGeometry(opts) {\n      Object.assign(this.opts, opts);\n      var _this$opts = this.opts,\n          data = _this$opts.data,\n          _this$opts$buffers = _this$opts.buffers,\n          buffers = _this$opts$buffers === void 0 ? {} : _this$opts$buffers,\n          getGeometry = _this$opts.getGeometry,\n          geometryBuffer = _this$opts.geometryBuffer,\n          positionFormat = _this$opts.positionFormat,\n          dataChanged = _this$opts.dataChanged,\n          _this$opts$normalize = _this$opts.normalize,\n          normalize = _this$opts$normalize === void 0 ? true : _this$opts$normalize;\n      this.data = data;\n      this.getGeometry = getGeometry;\n      this.positionSize = geometryBuffer && geometryBuffer.size || (positionFormat === 'XY' ? 2 : 3);\n      this.buffers = buffers;\n      this.normalize = normalize;\n\n      if (geometryBuffer) {\n        assert(data.startIndices, 'binary data missing startIndices');\n        this.getGeometry = this.getGeometryFromBuffer(geometryBuffer);\n\n        if (!normalize) {\n          buffers.positions = geometryBuffer;\n        }\n      }\n\n      this.geometryBuffer = buffers.positions;\n\n      if (Array.isArray(dataChanged)) {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = dataChanged[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var dataRange = _step.value;\n\n            this._rebuildGeometry(dataRange);\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n              _iterator[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      } else {\n        this._rebuildGeometry();\n      }\n    }\n  }, {\n    key: \"updatePartialGeometry\",\n    value: function updatePartialGeometry(_ref) {\n      var startRow = _ref.startRow,\n          endRow = _ref.endRow;\n\n      this._rebuildGeometry({\n        startRow: startRow,\n        endRow: endRow\n      });\n    }\n  }, {\n    key: \"normalizeGeometry\",\n    value: function normalizeGeometry(geometry) {\n      return geometry;\n    }\n  }, {\n    key: \"updateGeometryAttributes\",\n    value: function updateGeometryAttributes(geometry, startIndex, size) {\n      throw new Error('Not implemented');\n    }\n  }, {\n    key: \"getGeometrySize\",\n    value: function getGeometrySize(geometry) {\n      throw new Error('Not implemented');\n    }\n  }, {\n    key: \"getGeometryFromBuffer\",\n    value: function getGeometryFromBuffer(geometryBuffer) {\n      var value = geometryBuffer.value || geometryBuffer;\n      assert(ArrayBuffer.isView(value), 'cannot read geometries');\n      return getAccessorFromBuffer(value, {\n        size: this.positionSize,\n        offset: geometryBuffer.offset,\n        stride: geometryBuffer.stride,\n        startIndices: this.data.startIndices\n      });\n    }\n  }, {\n    key: \"_allocate\",\n    value: function _allocate(instanceCount, copy) {\n      var attributes = this.attributes,\n          buffers = this.buffers,\n          _attributeDefs = this._attributeDefs,\n          typedArrayManager = this.typedArrayManager;\n\n      for (var name in _attributeDefs) {\n        if (name in buffers) {\n          typedArrayManager.release(attributes[name]);\n          attributes[name] = null;\n        } else {\n          var def = _attributeDefs[name];\n          def.copy = copy;\n          attributes[name] = typedArrayManager.allocate(attributes[name], instanceCount, def);\n        }\n      }\n    }\n  }, {\n    key: \"_forEachGeometry\",\n    value: function _forEachGeometry(visitor, startRow, endRow) {\n      var data = this.data,\n          getGeometry = this.getGeometry;\n\n      var _createIterable = createIterable(data, startRow, endRow),\n          iterable = _createIterable.iterable,\n          objectInfo = _createIterable.objectInfo;\n\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = iterable[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var object = _step2.value;\n          objectInfo.index++;\n          var geometry = getGeometry(object, objectInfo);\n          visitor(geometry, objectInfo.index);\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n            _iterator2[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_rebuildGeometry\",\n    value: function _rebuildGeometry(dataRange) {\n      var _this = this;\n\n      if (!this.data || !this.getGeometry) {\n        return;\n      }\n\n      var indexStarts = this.indexStarts,\n          vertexStarts = this.vertexStarts,\n          instanceCount = this.instanceCount;\n      var data = this.data,\n          geometryBuffer = this.geometryBuffer;\n\n      var _ref2 = dataRange || {},\n          _ref2$startRow = _ref2.startRow,\n          startRow = _ref2$startRow === void 0 ? 0 : _ref2$startRow,\n          _ref2$endRow = _ref2.endRow,\n          endRow = _ref2$endRow === void 0 ? Infinity : _ref2$endRow;\n\n      var normalizedData = {};\n\n      if (!dataRange) {\n        indexStarts = [0];\n        vertexStarts = [0];\n      }\n\n      if (this.normalize || !geometryBuffer) {\n        this._forEachGeometry(function (geometry, dataIndex) {\n          geometry = _this.normalizeGeometry(geometry);\n          normalizedData[dataIndex] = geometry;\n          vertexStarts[dataIndex + 1] = vertexStarts[dataIndex] + _this.getGeometrySize(geometry);\n        }, startRow, endRow);\n\n        instanceCount = vertexStarts[vertexStarts.length - 1];\n      } else if (geometryBuffer.buffer instanceof Buffer) {\n        var byteStride = geometryBuffer.stride || this.positionSize * 4;\n        vertexStarts = data.startIndices;\n        instanceCount = vertexStarts[data.length] || geometryBuffer.buffer.byteLength / byteStride;\n      } else {\n        var bufferValue = geometryBuffer.value || geometryBuffer;\n        var elementStride = geometryBuffer.stride / bufferValue.BYTES_PER_ELEMENT || this.positionSize;\n        vertexStarts = data.startIndices;\n        instanceCount = vertexStarts[data.length] || bufferValue.length / elementStride;\n      }\n\n      this._allocate(instanceCount, Boolean(dataRange));\n\n      this.indexStarts = indexStarts;\n      this.vertexStarts = vertexStarts;\n      this.instanceCount = instanceCount;\n      var context = {};\n\n      this._forEachGeometry(function (geometry, dataIndex) {\n        geometry = normalizedData[dataIndex] || geometry;\n        context.vertexStart = vertexStarts[dataIndex];\n        context.indexStart = indexStarts[dataIndex];\n        var vertexEnd = dataIndex < vertexStarts.length - 1 ? vertexStarts[dataIndex + 1] : instanceCount;\n        context.geometrySize = vertexEnd - vertexStarts[dataIndex];\n        context.geometryIndex = dataIndex;\n\n        _this.updateGeometryAttributes(geometry, context);\n      }, startRow, endRow);\n\n      this.vertexCount = indexStarts[indexStarts.length - 1];\n    }\n  }]);\n\n  return Tesselator;\n}();\n\nexport { Tesselator as default };"],"sourceRoot":""}