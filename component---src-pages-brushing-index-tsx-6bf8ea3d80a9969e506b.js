(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{"+2Bo":function(e,t,n){"use strict";n.d(t,"a",(function(){return f}));var i=n("9fIP"),o=n("MMYH"),s=n("K/z8"),r=n("sRHE"),a=n("PRnZ"),l=n("8K1b"),c=n("D8sA"),u=n("8eia"),g=n("TjKm"),d=n("CPJl"),h=n("u/Ma"),p=[0,0,0,255],v={radiusUnits:"meters",radiusScale:{type:"number",min:0,value:1},radiusMinPixels:{type:"number",min:0,value:0},radiusMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},lineWidthUnits:"meters",lineWidthScale:{type:"number",min:0,value:1},lineWidthMinPixels:{type:"number",min:0,value:0},lineWidthMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},stroked:!1,filled:!0,getPosition:{type:"accessor",value:function(e){return e.position}},getRadius:{type:"accessor",value:1},getFillColor:{type:"accessor",value:p},getLineColor:{type:"accessor",value:p},getLineWidth:{type:"accessor",value:1},strokeWidth:{deprecatedFor:"getLineWidth"},outline:{deprecatedFor:"stroked"},getColor:{deprecatedFor:["getFillColor","getLineColor"]}},f=function(e){function t(){return Object(i.a)(this,t),Object(s.a)(this,Object(r.a)(t).apply(this,arguments))}return Object(l.a)(t,e),Object(o.a)(t,[{key:"getShaders",value:function(e){return Object(a.a)(Object(r.a)(t.prototype),"getShaders",this).call(this,{vs:"#define SHADER_NAME scatterplot-layer-vertex-shader\n\nattribute vec3 positions;\n\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute float instanceRadius;\nattribute float instanceLineWidths;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute vec3 instancePickingColors;\n\nuniform float opacity;\nuniform float radiusScale;\nuniform float radiusMinPixels;\nuniform float radiusMaxPixels;\nuniform float lineWidthScale;\nuniform float lineWidthMinPixels;\nuniform float lineWidthMaxPixels;\nuniform float stroked;\nuniform bool filled;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying vec2 unitPosition;\nvarying float innerUnitRadius;\nvarying float outerRadiusPixels;\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  outerRadiusPixels = clamp(\n    project_size_to_pixel(radiusScale * instanceRadius),\n    radiusMinPixels, radiusMaxPixels\n  );\n  float lineWidthPixels = clamp(\n    project_size_to_pixel(lineWidthScale * instanceLineWidths),\n    lineWidthMinPixels, lineWidthMaxPixels\n  );\n  outerRadiusPixels += stroked * lineWidthPixels / 2.0;\n  unitPosition = positions.xy;\n  geometry.uv = unitPosition;\n  geometry.pickingColor = instancePickingColors;\n\n  innerUnitRadius = 1.0 - stroked * lineWidthPixels / outerRadiusPixels;\n  \n  vec3 offset = positions * project_pixel_size(outerRadiusPixels);\n  DECKGL_FILTER_SIZE(offset, geometry);\n  gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset, geometry.position);\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity);\n  DECKGL_FILTER_COLOR(vFillColor, geometry);\n  vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity);\n  DECKGL_FILTER_COLOR(vLineColor, geometry);\n}\n",fs:"#define SHADER_NAME scatterplot-layer-fragment-shader\n\nprecision highp float;\n\nuniform bool filled;\nuniform float stroked;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying vec2 unitPosition;\nvarying float innerUnitRadius;\nvarying float outerRadiusPixels;\n\nvoid main(void) {\n  geometry.uv = unitPosition;\n\n  float distToCenter = length(unitPosition) * outerRadiusPixels;\n  float inCircle = smoothedge(distToCenter, outerRadiusPixels);\n\n  if (inCircle == 0.0) {\n    discard;\n  }\n\n  if (stroked > 0.5) {\n    float isLine = smoothedge(innerUnitRadius * outerRadiusPixels, distToCenter);\n    if (filled) {\n      gl_FragColor = mix(vFillColor, vLineColor, isLine);\n    } else {\n      if (isLine == 0.0) {\n        discard;\n      }\n      gl_FragColor = vec4(vLineColor.rgb, vLineColor.a * isLine);\n    }\n  } else if (filled) {\n    gl_FragColor = vFillColor;\n  } else {\n    discard;\n  }\n\n  gl_FragColor.a *= inCircle;\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",modules:[c.a,u.a]})}},{key:"initializeState",value:function(){this.getAttributeManager().addInstanced({instancePositions:{size:3,type:5130,fp64:this.use64bitPositions(),transition:!0,accessor:"getPosition"},instanceRadius:{size:1,transition:!0,accessor:"getRadius",defaultValue:1},instanceFillColors:{size:this.props.colorFormat.length,transition:!0,normalized:!0,type:5121,accessor:"getFillColor",defaultValue:[0,0,0,255]},instanceLineColors:{size:this.props.colorFormat.length,transition:!0,normalized:!0,type:5121,accessor:"getLineColor",defaultValue:[0,0,0,255]},instanceLineWidths:{size:1,transition:!0,accessor:"getLineWidth",defaultValue:1}})}},{key:"updateState",value:function(e){var n=e.props,i=e.oldProps,o=e.changeFlags;if(Object(a.a)(Object(r.a)(t.prototype),"updateState",this).call(this,{props:n,oldProps:i,changeFlags:o}),o.extensionsChanged){var s=this.context.gl;this.state.model&&this.state.model.delete(),this.setState({model:this._getModel(s)}),this.getAttributeManager().invalidateAll()}}},{key:"draw",value:function(e){var t=e.uniforms,n=this.context.viewport,i=this.props,o=i.radiusUnits,s=i.radiusScale,r=i.radiusMinPixels,a=i.radiusMaxPixels,l=i.stroked,c=i.filled,u=i.lineWidthUnits,g=i.lineWidthScale,d=i.lineWidthMinPixels,h=i.lineWidthMaxPixels,p="pixels"===o?n.metersPerPixel:1,v="pixels"===u?n.metersPerPixel:1;this.state.model.setUniforms(t).setUniforms({stroked:l?1:0,filled:c,radiusScale:s*p,radiusMinPixels:r,radiusMaxPixels:a,lineWidthScale:g*v,lineWidthMinPixels:d,lineWidthMaxPixels:h}).draw()}},{key:"_getModel",value:function(e){return new d.a(e,Object.assign(this.getShaders(),{id:this.props.id,geometry:new h.a({drawMode:6,vertexCount:4,attributes:{positions:{size:3,value:new Float32Array([-1,-1,0,1,-1,0,1,1,0,-1,1,0])}}}),isInstanced:!0}))}}]),t}(g.a);f.layerName="ScatterplotLayer",f.defaultProps=v},gWcq:function(e,t,n){"use strict";n.r(t),n.d(t,"inFlowColors",(function(){return E})),n.d(t,"outFlowColors",(function(){return O}));var i=n("BFfR"),o=n("NMl0"),s=n("+2Bo"),r=n("9fIP"),a=n("MMYH"),l=n("K/z8"),c=n("sRHE"),u=n("PRnZ"),g=n("8K1b"),d=n("D8sA"),h=n("8eia"),p=n("TjKm"),v=n("CPJl"),f=n("u/Ma"),m=[0,0,0,255],b={getSourcePosition:{type:"accessor",value:function(e){return e.sourcePosition}},getTargetPosition:{type:"accessor",value:function(e){return e.targetPosition}},getSourceColor:{type:"accessor",value:m},getTargetColor:{type:"accessor",value:m},getWidth:{type:"accessor",value:1},getHeight:{type:"accessor",value:1},getTilt:{type:"accessor",value:0},greatCircle:!1,widthUnits:"pixels",widthScale:{type:"number",value:1,min:0},widthMinPixels:{type:"number",value:0,min:0},widthMaxPixels:{type:"number",value:Number.MAX_SAFE_INTEGER,min:0}},P=function(e){function t(){return Object(r.a)(this,t),Object(l.a)(this,Object(c.a)(t).apply(this,arguments))}return Object(g.a)(t,e),Object(a.a)(t,[{key:"getShaders",value:function(){return Object(u.a)(Object(c.a)(t.prototype),"getShaders",this).call(this,{vs:"#define SHADER_NAME arc-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec4 instanceSourceColors;\nattribute vec4 instanceTargetColors;\nattribute vec3 instanceSourcePositions;\nattribute vec3 instanceSourcePositions64Low;\nattribute vec3 instanceTargetPositions;\nattribute vec3 instanceTargetPositions64Low;\nattribute vec3 instancePickingColors;\nattribute float instanceWidths;\nattribute float instanceHeights;\nattribute float instanceTilts;\n\nuniform bool greatCircle;\nuniform float numSegments;\nuniform float opacity;\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\n\nvarying vec4 vColor;\nvarying vec2 uv;\nvarying float isValid;\n\nfloat paraboloid(float distance, float sourceZ, float targetZ, float ratio) {\n\n  float deltaZ = targetZ - sourceZ;\n  float dh = distance * instanceHeights;\n  float unitZ = dh == 0.0 ? 0.0 : deltaZ / dh;\n  float p2 = unitZ * unitZ + 1.0;\n  float dir = step(deltaZ, 0.0);\n  float z0 = mix(sourceZ, targetZ, dir);\n  float r = mix(ratio, 1.0 - ratio, dir);\n  return sqrt(r * (p2 - r)) * dh + z0;\n}\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {\n  vec2 dir_screenspace = normalize(line_clipspace * project_uViewportSize);\n  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n\n  return dir_screenspace * offset_direction * width / 2.0;\n}\n\nfloat getSegmentRatio(float index) {\n  return smoothstep(0.0, 1.0, index / (numSegments - 1.0));\n}\n\nvec3 interpolateFlat(vec3 source, vec3 target, float segmentRatio) {\n  float distance = length(source.xy - target.xy);\n  float z = paraboloid(distance, source.z, target.z, segmentRatio);\n\n  float tiltAngle = radians(instanceTilts);\n  vec2 tiltDirection = normalize(target.xy - source.xy);\n  vec2 tilt = vec2(-tiltDirection.y, tiltDirection.x) * z * sin(tiltAngle);\n\n  return vec3(\n    mix(source.xy, target.xy, segmentRatio) + tilt,\n    z * cos(tiltAngle)\n  );\n}\nfloat getAngularDist (vec2 source, vec2 target) {\n  vec2 sourceRadians = radians(source);\n  vec2 targetRadians = radians(target);\n  vec2 sin_half_delta = sin((sourceRadians - targetRadians) / 2.0);\n  vec2 shd_sq = sin_half_delta * sin_half_delta;\n\n  float a = shd_sq.y + cos(sourceRadians.y) * cos(targetRadians.y) * shd_sq.x;\n  return 2.0 * asin(sqrt(a));\n}\n\nvec3 interpolateGreatCircle(vec3 source, vec3 target, vec3 source3D, vec3 target3D, float angularDist, float t) {\n  vec2 lngLat;\n  if(abs(angularDist - PI) < 0.001) {\n    lngLat = (1.0 - t) * source.xy + t * target.xy;\n  } else {\n    float a = sin((1.0 - t) * angularDist);\n    float b = sin(t * angularDist);\n    vec3 p = source3D.yxz * a + target3D.yxz * b;\n    lngLat = degrees(vec2(atan(p.y, -p.x), atan(p.z, length(p.xy))));\n  }\n\n  float z = paraboloid(angularDist * EARTH_RADIUS, source.z, target.z, t);\n\n  return vec3(lngLat, z);\n}\n\nvoid main(void) {\n  geometry.worldPosition = instanceSourcePositions;\n  geometry.worldPositionAlt = instanceTargetPositions;\n\n  float segmentIndex = positions.x;\n  float segmentRatio = getSegmentRatio(segmentIndex);\n  float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));\n  isValid = 1.0;\n\n  uv = vec2(segmentRatio, positions.y);\n  geometry.uv = uv;\n  geometry.pickingColor = instancePickingColors;\n\n  vec4 curr;\n  vec4 next;\n  vec3 source;\n  vec3 target;\n\n  if ((greatCircle || project_uProjectionMode == PROJECTION_MODE_GLOBE) && project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n    source = project_globe_(vec3(instanceSourcePositions.xy, 0.0));\n    target = project_globe_(vec3(instanceTargetPositions.xy, 0.0));\n    float angularDist = getAngularDist(instanceSourcePositions.xy, instanceTargetPositions.xy);\n  \n    float prevSegmentRatio = getSegmentRatio(max(0.0, segmentIndex - 1.0));\n    float nextSegmentRatio = getSegmentRatio(min(numSegments, segmentIndex + 1.0));\n\n    vec3 prevPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, prevSegmentRatio);\n    vec3 currPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, segmentRatio);\n    vec3 nextPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, nextSegmentRatio);\n\n    if (abs(currPos.x - prevPos.x) > 180.0) {\n      indexDir = -1.0;\n      isValid = 0.0;\n    } else if (abs(currPos.x - nextPos.x) > 180.0) {\n      indexDir = 1.0;\n      isValid = 0.0;\n    }\n    nextPos = indexDir < 0.0 ? prevPos : nextPos;\n    nextSegmentRatio = indexDir < 0.0 ? prevSegmentRatio : nextSegmentRatio;\n\n    if (isValid == 0.0) {\n      nextPos.x += nextPos.x > 0.0 ? -360.0 : 360.0;\n      float t = ((currPos.x > 0.0 ? 180.0 : -180.0) - currPos.x) / (nextPos.x - currPos.x);\n      currPos = mix(currPos, nextPos, t);\n      segmentRatio = mix(segmentRatio, nextSegmentRatio, t);\n    }\n\n    vec3 currPos64Low = mix(instanceSourcePositions64Low, instanceTargetPositions64Low, segmentRatio);\n    vec3 nextPos64Low = mix(instanceSourcePositions64Low, instanceTargetPositions64Low, nextSegmentRatio);\n  \n    curr = project_position_to_clipspace(currPos, currPos64Low, vec3(0.0), geometry.position);\n    next = project_position_to_clipspace(nextPos, nextPos64Low, vec3(0.0));\n  \n  } else {\n    source = project_position(instanceSourcePositions, instanceSourcePositions64Low);\n    target = project_position(instanceTargetPositions, instanceTargetPositions64Low);\n\n    float nextSegmentRatio = getSegmentRatio(segmentIndex + indexDir);\n    vec3 currPos = interpolateFlat(source, target, segmentRatio);\n    vec3 nextPos = interpolateFlat(source, target, nextSegmentRatio);\n    curr = project_common_position_to_clipspace(vec4(currPos, 1.0));\n    next = project_common_position_to_clipspace(vec4(nextPos, 1.0));\n    geometry.position = vec4(currPos, 1.0);\n  }\n  float widthPixels = clamp(\n    project_size_to_pixel(instanceWidths * widthScale),\n    widthMinPixels, widthMaxPixels\n  );\n  vec3 offset = vec3(\n    getExtrusionOffset((next.xy - curr.xy) * indexDir, positions.y, widthPixels),\n    0.0);\n  DECKGL_FILTER_SIZE(offset, geometry);\n  gl_Position = curr + vec4(project_pixel_size_to_clipspace(offset.xy), 0.0, 0.0);\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  vec4 color = mix(instanceSourceColors, instanceTargetColors, segmentRatio);\n  vColor = vec4(color.rgb, color.a * opacity);\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n",fs:"#define SHADER_NAME arc-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\nvarying vec2 uv;\nvarying float isValid;\n\nvoid main(void) {\n  if (isValid == 0.0) {\n    discard;\n  }\n\n  gl_FragColor = vColor;\n  geometry.uv = uv;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",modules:[d.a,h.a]})}},{key:"initializeState",value:function(){this.getAttributeManager().addInstanced({instanceSourcePositions:{size:3,type:5130,fp64:this.use64bitPositions(),transition:!0,accessor:"getSourcePosition"},instanceTargetPositions:{size:3,type:5130,fp64:this.use64bitPositions(),transition:!0,accessor:"getTargetPosition"},instanceSourceColors:{size:this.props.colorFormat.length,type:5121,normalized:!0,transition:!0,accessor:"getSourceColor",defaultValue:m},instanceTargetColors:{size:this.props.colorFormat.length,type:5121,normalized:!0,transition:!0,accessor:"getTargetColor",defaultValue:m},instanceWidths:{size:1,transition:!0,accessor:"getWidth",defaultValue:1},instanceHeights:{size:1,transition:!0,accessor:"getHeight",defaultValue:1},instanceTilts:{size:1,transition:!0,accessor:"getTilt",defaultValue:0}})}},{key:"updateState",value:function(e){var n=e.props,i=e.oldProps,o=e.changeFlags;if(Object(u.a)(Object(c.a)(t.prototype),"updateState",this).call(this,{props:n,oldProps:i,changeFlags:o}),o.extensionsChanged){var s=this.context.gl;this.state.model&&this.state.model.delete(),this.setState({model:this._getModel(s)}),this.getAttributeManager().invalidateAll()}}},{key:"draw",value:function(e){var t=e.uniforms,n=this.context.viewport,i=this.props,o=i.widthUnits,s=i.widthScale,r=i.widthMinPixels,a=i.widthMaxPixels,l=i.greatCircle,c="pixels"===o?n.metersPerPixel:1;this.state.model.setUniforms(t).setUniforms({greatCircle:l,widthScale:s*c,widthMinPixels:r,widthMaxPixels:a}).draw()}},{key:"_getModel",value:function(e){for(var t=[],n=0;n<50;n++)t=t.concat([n,1,0,n,-1,0]);var i=new v.a(e,Object.assign({},this.getShaders(),{id:this.props.id,geometry:new f.a({drawMode:5,attributes:{positions:new Float32Array(t)}}),isInstanced:!0}));return i.setUniforms({numSegments:50}),i}}]),t}(p.a);P.layerName="ArcLayer",P.defaultProps=b;var x=n("A4LX"),y=function(){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};Object(r.a)(this,e),this.opts=t}return Object(a.a)(e,[{key:"equals",value:function(e){return this===e||this.constructor===e.constructor&&Object(x.a)(this.opts,e.opts)}},{key:"getShaders",value:function(e){return null}},{key:"getSubLayerProps",value:function(e){var t=e.constructor.defaultProps,n=void 0===t?{}:t,i={updateTriggers:{}};for(var o in n)if(o in this.props){var s=n[o],r=this.props[o];i[o]=r,s&&"accessor"===s.type&&(i.updateTriggers[o]=this.props.updateTriggers[o],"function"==typeof r&&(i[o]=this.getSubLayerAccessor(r,!0)))}return i}},{key:"initializeState",value:function(e,t){}},{key:"updateState",value:function(e,t){}},{key:"draw",value:function(e,t){}},{key:"finalizeState",value:function(e){}}]),e}(),_=n("oCE4"),C={source:0,target:1,custom:2,source_target:3},S={name:"brushing",dependencies:[_.a],vs:"\n  uniform bool brushing_enabled;\n  uniform int brushing_target;\n  uniform vec2 brushing_mousePos;\n  uniform float brushing_radius;\n\n  #ifdef NON_INSTANCED_MODEL\n  attribute vec2 brushingTargets;\n  #else\n  attribute vec2 instanceBrushingTargets;\n  #endif\n\n  varying float brushing_isVisible;\n\n  bool brushing_isPointInRange(vec2 position) {\n    if (!brushing_enabled) {\n      return true;\n    }\n    vec2 source_commonspace = project_position(position);\n    vec2 target_commonspace = project_position(brushing_mousePos);\n    float distance = length((target_commonspace - source_commonspace) / project_uCommonUnitsPerMeter.xy);\n\n    return distance <= brushing_radius;\n  }\n\n  bool brushing_arePointsInRange(vec2 sourcePos, vec2 targetPos) {\n    return brushing_isPointInRange(sourcePos) || brushing_isPointInRange(targetPos);\n  }\n\n  void brushing_setVisible(bool visible) {\n    brushing_isVisible = float(visible);\n  }\n",fs:"\n  uniform bool brushing_enabled;\n  varying float brushing_isVisible;\n",inject:{"vs:DECKGL_FILTER_GL_POSITION":"\n    vec2 brushingTarget;\n    vec2 brushingSource;\n    if (brushing_target == 3) {\n      brushingTarget = geometry.worldPositionAlt.xy;\n      brushingSource = geometry.worldPosition.xy;\n    } else if (brushing_target == 0) {\n      brushingTarget = geometry.worldPosition.xy;\n    } else if (brushing_target == 1) {\n      brushingTarget = geometry.worldPositionAlt.xy;\n    } else {\n      #ifdef NON_INSTANCED_MODEL\n      brushingTarget = brushingTargets;\n      #else\n      brushingTarget = instanceBrushingTargets;\n      #endif\n    }\n    bool visible;\n    if (brushing_target == 3) {\n      visible = brushing_arePointsInRange(brushingSource, brushingTarget);\n    } else {\n      visible = brushing_isPointInRange(brushingTarget);\n    }\n    brushing_setVisible(visible);\n  ","fs:DECKGL_FILTER_COLOR":"\n    if (brushing_enabled && brushing_isVisible < 0.5) {\n      discard;\n    }\n  "},getUniforms:function(e){if(!e||!e.viewport)return{};var t=e.brushingEnabled,n=void 0===t||t,i=e.brushingRadius,o=void 0===i?1e4:i,s=e.brushingTarget,r=void 0===s?"source":s,a=e.mousePosition,l=e.viewport;return{brushing_enabled:Boolean(n&&a&&l.containsPixel(a)),brushing_radius:o,brushing_target:C[r]||0,brushing_mousePos:a?l.unproject([a.x-l.x,a.y-l.y]):[0,0]}}},R=function(e){function t(){return Object(r.a)(this,t),Object(l.a)(this,Object(c.a)(t).apply(this,arguments))}return Object(g.a)(t,e),Object(a.a)(t,[{key:"getShaders",value:function(e){return{modules:[S]}}},{key:"initializeState",value:function(e,t){var n=this,i=this.getAttributeManager();i&&i.add({brushingTargets:{size:2,accessor:"getBrushingTarget",update:!this.props.getBrushingTarget&&t.useConstantTargetPositions,shaderAttributes:{brushingTargets:{divisor:0},instanceBrushingTargets:{divisor:1}}}}),t.onMouseMove=function(){n.getCurrentLayer().setNeedsRedraw()},this.context.deck&&this.context.deck.eventManager.on({pointermove:t.onMouseMove,pointerleave:t.onMouseMove})}},{key:"finalizeState",value:function(e){this.context.deck&&this.context.deck.eventManager.off({pointermove:e.onMouseMove,pointerleave:e.onMouseMove})}},{key:"useConstantTargetPositions",value:function(e){e.constant=!0,e.value=new Float32Array(2)}}]),t}(y);R.extensionName="BrushingExtension",R.defaultProps={getBrushingTarget:{type:"accessor",value:[0,0]},brushingTarget:"source",brushingEnabled:!0,brushingRadius:1e4};var L=n("ZRAw"),M=n("/PUF"),T=[166,3,3],w=[35,181,184],E=[[35,181,184]],O=[[166,3,3]],j=new R;var k=function(e){function t(t){var n;return(n=e.call(this,t)||this).state={data:[],enableBrushing:!0,brushRadius:1e5,strokeWidth:2,opacity:.7},n.deckLayer=null,n.viewState={center:[-100,40.7],zoom:3,pitch:40.5,bearing:0},n}Object(i.a)(t,e);var n=t.prototype;return n.initMap=function(){var t=this;e.prototype.initMap.call(this),fetch("https://raw.githubusercontent.com/visgl/deck.gl-data/master/examples/arc/counties.json").then((function(e){return e.json()})).then((function(e){var n=e.features;t.setState({data:n},(function(){t._renderLayers()}))}))},n.componentWillUnmount=function(){this.deckLayer&&this.deckLayer.remove(),e.prototype.componentWillUnmount.call(this)},n._renderLayers=function(){var e=this,t=this.state,n=t.enableBrushing,i=void 0===n||n,r=t.brushRadius,a=void 0===r?1e5:r,l=t.strokeWidth,c=void 0===l?2:l,u=t.opacity,g=void 0===u?.7:u,d=function(e){if(!e||!e.length)return{};var t=[],n=[],i=[],o={};e.forEach((function(s,r){var a=s.properties,l=a.flows,c=a.centroid,u={gain:0,loss:0};Object.keys(l).forEach((function(n){if(u[l[n]>0?"gain":"loss"]+=l[n],!(Math.abs(l[n])<50)){var s=[r,Number(n)].sort((function(e,t){return e-t})).join("-"),a=e[n].properties.centroid,g=Math.sign(l[n]);i.push({position:a,target:c,name:e[n].properties.name,radius:3,gain:-g}),o[s]||(o[s]=!0,t.push({target:g>0?c:a,source:g>0?a:c,value:l[n]}))}})),n.push(Object.assign({},u,{position:[c[0],c[1],10],net:u.gain+u.loss,name:s.properties.name}))})),n.sort((function(e,t){return Math.abs(t.net)-Math.abs(e.net)}));var s=Object(L.a)().domain([0,Math.abs(n[0].net)]).range([36,400]);return n.forEach((function(e){e.radius=Math.sqrt(s(Math.abs(e.net)))})),{arcs:t,targets:n,sources:i}}(t.data),h=d.arcs,p=d.targets,v=d.sources;try{var f={layers:[new s.a({id:"sources",data:v,brushingRadius:a,brushingEnabled:i,radiusScale:i?3e3:0,getFillColor:function(e){return e.gain>0?w:T},extensions:[j]}),new s.a({id:"targets-ring",data:p,brushingRadius:a,lineWidthMinPixels:2,stroked:!0,filled:!1,brushingEnabled:i,radiusScale:i?4e3:0,getLineColor:function(e){return e.net>0?w:T},extensions:[j]}),new s.a({id:"targets",data:p,brushingRadius:a,brushingEnabled:i,pickable:!0,radiusScale:3e3,getFillColor:function(e){return e.net>0?w:T},extensions:[j]}),new P({id:"arc",data:h,getWidth:c,opacity:g,brushingRadius:a,brushingEnabled:i,getSourcePosition:function(e){return e.source},getTargetPosition:function(e){return e.target},getSourceColor:T,getTargetColor:w,extensions:[j]})]};this.deckLayer?this.deckLayer.setProps(f):(console.log(this.deckLayer),this.deckLayer=new o.a("deck",f,{animation:!0,forceRenderOnMoving:!0,forceRenderOnZooming:!0,renderStart:function(){var t;null===(t=e.renderState)||void 0===t||t.update()}}),this.map.addLayer(this.deckLayer),console.log(this.deckLayer))}catch(m){console.error(m)}},t}(M.default);t.default=k}}]);
//# sourceMappingURL=component---src-pages-brushing-index-tsx-6bf8ea3d80a9969e506b.js.map